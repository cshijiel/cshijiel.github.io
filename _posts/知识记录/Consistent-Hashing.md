title: "一致性Hash算法"
date: 2016-05-23 13:20:20
tags:
- Hash
- 一致性Hash

categories: 知识记录

------

### 一致性Hash算法是什么？

> 一致性哈希（Consistent Hashing），是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对K/n 个关键字重新映射，其中 K是关键字的数量，n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。
>
> --wiki

现在这种思想已经被广泛的应用在了其他领域，尤其是分布式系统非常流行的今天。

### 解决的问题

在分布式系统中，比如典型的KV型缓存系统，存储的位置一般是通过hash(key)得到的值确定的。比较简单的，例如，通过hash(key) % N,确定存储的节点,其中N是存储节点个数。这是最简单直观的做法，但是有一个比较严重的问题，如果有新的机器加入或者退出，基本上所有的映射都对用不上了。

$$
hash(Key)\pmod N
$$

为了能够随时增加、减少机器并且造成的映射变化最小，在此基础上还可以尽可能的使内容比较均匀的分布在每个存储节点上等，1997年由麻省理工学院提出的一种分布式哈希（DHT，Distributed Hash Table，分布式哈希表）实现算法，即一致性哈希算法。

<!-- more -->

### 一致性hash的特点

好的一致性算法需满足以下几个方面：

- 平衡性（Balance）

  平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。


- 单调性(Monotonicity)

  单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。


- 分散性(Spread)

  在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。


- 负载(Load)

  负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。

- 平滑性(Smoothness)

  平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。

如果可以满足以上几个方面，则可以很低成本的增加、减少机器，这个分布式系统也就更加健壮。

### 实现原理<转>

不同于取模直接定位（可以认为是数学中的等式）存储节点的方式，一致性hash一般采用环形Hash空间的方式，从这个环上取几个节点，就近（或者顺时针、逆时针就近）存储，这样就变成了不等式的方式，更为灵活。

#### 环形Hash空间

一致性哈希将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希空间环如下：

![一致性Hash环形空间](http://7d9owd.com1.z0.glb.clouddn.com/16-5-23/87078665.jpg)

#### 将机器和存储的内容Hash落在环形空间

首先将服务器通过使用某个Hash算法，映射到环形空间的某个位置，具体做法可以通过Hash(serverName or IP, etc),这样就会得到每个节点的位置。

例如有A、B、C、D四个存储节点，Hash后如下：

![存储节点在环形空间的分布](http://7d9owd.com1.z0.glb.clouddn.com/16-5-23/65633344.jpg)

然后将存储内容计算出Hash值，落在环形空间某一位置，接着顺时针寻找到第一个存储节点，存储完成。

例如有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置与节点的对应关系如下：

![存储内容最终定位到服务节点](http://7d9owd.com1.z0.glb.clouddn.com/16-5-23/53690418.jpg)

根据一致性哈希算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。

##### 分析

下面分析一致性哈希算法的容错性和可扩展性。现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性哈希算法中，如果一个节点不可用，则受影响的数据仅仅是此服务器到其环空间中前一个节点（即沿着逆时针方向行走遇到的第一个节点）之间数据，其它不会受到影响。

下面考虑另外一种情况，如果在系统中增加一个节点Node X，如下图所示：

 ![新增Node X](http://7d9owd.com1.z0.glb.clouddn.com/16-5-23/27515656.jpg)

此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X 。一般的，在一致性哈希算法中，如果增加一个节点，则受影响的数据仅仅是新节点到其环空间中前一个节点（即沿着逆时针方向行走遇到的第一个节点）之间数据，其它数据也不会受到影响。

综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，**具有较好的容错性和可扩展性**。

#### 虚拟节点

假如，在这个分布式系统中，服务节点在环形空间分布不均衡时，容易造成数据存储倾斜问题。假如只有2个节点其环分布分布如下：

![更加不均匀的服务节点分布](http://7d9owd.com1.z0.glb.clouddn.com/16-5-23/6466285.jpg)

此时必然造成大量数据集中到Node A上，而只有少量会定位到Node B上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器ip或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：

![虚拟节点](http://7d9owd.com1.z0.glb.clouddn.com/16-5-23/54897555.jpg)

同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。

### 延伸阅读：

[一致性Hash背景](http://www.cnblogs.com/haippy/archive/2011/12/10/2282943.html)

一致性哈希. http://baike.baidu.com/view/1588037.htm



