<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="诚信，认真，专注，踏实" />



  <meta name="keywords" content="Java,互联网,NodeJS" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="诚信，认真，专注，踏实">
<meta property="og:type" content="website">
<meta property="og:title" content="Roc`s 随想录">
<meta property="og:url" content="http://coderroc.com/page/5/index.html">
<meta property="og:site_name" content="Roc`s 随想录">
<meta property="og:description" content="诚信，认真，专注，踏实">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Roc`s 随想录">
<meta name="twitter:description" content="诚信，认真，专注，踏实">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'hide'
  };
</script>

  <title> Roc`s 随想录 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Roc`s 随想录</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/知识记录/Linux基础/Linux Shell入门/" itemprop="url">
                Linux Shell入门
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Linux基础/" itemprop="url" rel="index">
                  <span itemprop="name">Linux基础</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/知识记录/Linux基础/Linux Shell入门/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/知识记录/Linux基础/Linux Shell入门/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="Shell简介：什么是Shell，Shell命令的两种执行方式">Shell简介：什么是Shell，Shell命令的两种执行方式</h2><p>Shell本身是一个用C语言编写的程序，它是用户使用Unix/Linux的桥梁，用户的大部分工作都是通过Shell完成的。Shell既是一种命令语言，又是一种程序设计语言。</p>
<p>可以说，shell使用的熟练程度反映了用户对Unix/Linux使用的熟练程度。</p>
<p><strong>Shell有两种执行命令的方式：</strong></p>
<ul>
<li>交互式（Interactive）：解释执行用户的命令，用户输入一条命令，Shell就解释执行一条。</li>
<li>批处理（Batch）：用户事先写一个Shell脚本(Script)，其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令。</li>
</ul>
<p>Shell脚本和编程语言很相似，<strong>也有变量和流程控制语句</strong>，但Shell脚本是解释执行的，不需要编译，Shell程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到Shell提示符下执行。</p>
<blockquote>
<p><em>Shell初学者请注意，在平常应用中，建议不要用 root 帐号运行 Shell 。作为普通用户，不管您有意还是无意，都无法破坏系统；但如果是 root，那就不同了，只要敲几个字母，就可能导致灾难性后果。</em></p>
</blockquote>
<h2 id="几种常见的Shell">几种常见的Shell</h2><p>Unix/Linux上常见的Shell脚本解释器有bash、sh、csh、ksh等，习惯上把它们称作一种Shell。我们常说有多少种Shell，其实说的是Shell脚本解释器。</p>
<p>其中：<code>sh</code><br>sh 由Steve Bourne开发，是Bourne Shell的缩写，sh 是Unix 标准默认的shell。</p>
<p>第一个Shell脚本（Shell的<code>HelloWorld</code>）<br>打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。</p>
<p>输入一些代码：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
<span class="built_in">echo</span> <span class="string">"Hello World !"</span>
</code></pre><p>“<code>#!</code>” 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell。echo命令用于向窗口输出文本。</p>
<p><strong>作为可执行程序</strong></p>
<p>将上面的代码保存为test.sh，并 cd 到相应目录：</p>
<pre><code>chmod +x ./<span class="keyword">test</span>.<span class="keyword">sh</span>  #使脚本具有执行权限
./<span class="keyword">test</span>.<span class="keyword">sh</span>  #执行脚本
</code></pre><p>注意，一定要写成<code>./test.sh</code>，而不是test.sh。运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，<strong>要用./test.sh告诉系统说，就在当前目录找。</strong></p>
<p>通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。</p>
<p>这里的”系统”，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。</p>
<p>再看一个例子。下面的脚本使用 <strong>read</strong> 命令从 stdin 获取输入并赋值给 PERSON 变量，最后在 stdout 上输出：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
<span class="comment"># Author : mozhiyan</span>
<span class="comment"># Copyright (c) http://see.xidian.edu.cn/cpp/linux/</span>
<span class="comment"># Script follows here:</span>
<span class="built_in">echo</span> <span class="string">"What is your name?"</span>
<span class="built_in">read</span> PERSON
<span class="built_in">echo</span> <span class="string">"Hello, <span class="variable">$PERSON</span>"</span>
</code></pre><p>运行脚本：</p>
<pre><code>chmod +x ./<span class="keyword">test</span>.<span class="keyword">sh</span>
$./<span class="keyword">test</span>.<span class="keyword">sh</span>
What is your name?
mozhiyan
Hello, mozhiyan
$
</code></pre><h2 id="Shell变量：Shell变量的定义、删除变量、只读变量、变量类型">Shell变量：Shell变量的定义、删除变量、只读变量、变量类型</h2><p><strong>定义变量</strong></p>
<p>定义变量时，变量名不加美元符号（$），如：</p>
<pre><code><span class="setting">variableName=<span class="value"><span class="string">"value"</span></span></span>
</code></pre><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p>
<ul>
<li>首个字符必须为字母（a-z，A-Z）。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>
</ul>
<p>变量定义举例：</p>
<pre><code><span class="setting">myUrl=<span class="value"><span class="string">"http://see.xidian.edu.cn/cpp/linux/"</span></span></span>
<span class="setting">myNum=<span class="value"><span class="number">100</span></span></span>
</code></pre><p><strong>使用变量</strong><br>使用一个定义过的变量，只要在变量名前面加美元符号（<code>$</code>）即可，如：</p>
<pre><code>your_name=<span class="string">"mozhiyan"</span>
echo <span class="variable">$your</span>_name
echo ${your_name}
</code></pre><p>变量名外面的花括号是<strong>可选的</strong>，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p>
<pre><code><span class="keyword">for</span> skill <span class="keyword">in</span> Ada Coffe Action Java 
<span class="keyword">do</span>
    <span class="built_in">echo</span> <span class="string">"I am good at <span class="variable">${skill}</span>Script"</span>
<span class="keyword">done</span>
</code></pre><p>如果不给skill变量加花括号，写成</p>
<pre><code><span class="built_in">echo</span> <span class="string">"I am good at <span class="variable">$skillScript</span>"</span>`
</code></pre><p>解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p>
<blockquote>
<p>推荐给所有变量加上花括号，这是个好的编程习惯。</p>
</blockquote>
<p><strong>重新定义变量</strong></p>
<p><strong>只读变量</strong></p>
<pre><code><span class="built_in">readonly</span> myUrl
</code></pre><p><strong>删除变量</strong></p>
<pre><code><span class="built_in">unset</span> variable_name
</code></pre><p><strong>变量类型</strong></p>
<p>运行shell时，会同时存在三种变量：</p>
<ol>
<li><p><strong>局部变量</strong><br>局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</p>
</li>
<li><p><strong>环境变量</strong><br>所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</p>
</li>
<li><strong>shell变量</strong><br>shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>
</ol>
<h2 id="Shell特殊变量：Shell_$0,_$#,_$*,_$@,_$?,_$$和命令行参数">Shell特殊变量：Shell $0, $#, $*, $@, $?, $$和命令行参数</h2><h2 id="Shell替换：Shell变量替换，命令替换，转义字符">Shell替换：Shell变量替换，命令替换，转义字符</h2><h2 id="Shell运算符：Shell算数运算符、关系运算符、布尔运算符、字符串运算符等">Shell运算符：Shell算数运算符、关系运算符、布尔运算符、字符串运算符等</h2><pre><code><span class="keyword">if</span> [ <span class="variable">$a</span> -le <span class="variable">$b</span> ]
<span class="keyword">then</span>
   echo <span class="string">"$a -le $b: a is less or  equal to b"</span>
<span class="keyword">else</span>
   echo <span class="string">"$a -le $b: a is not less or equal to b"</span>
fi
</code></pre><h2 id="Shell字符串">Shell字符串</h2><ul>
<li>单引号（原样输出）</li>
<li>双引号（可以转义、变量等）</li>
<li>拼接字符串</li>
<li>获取字符串长度</li>
<li>提取字符串</li>
<li>查找字符串</li>
</ul>
<h2 id="Shell数组：shell数组的定义、数组长度">Shell数组：shell数组的定义、数组长度</h2><ul>
<li>定义数组</li>
<li>读取数组</li>
<li>获取数组的长度</li>
</ul>
<h2 id="Shell_echo命令">Shell echo命令</h2><h2 id="shell_printf命令：格式化输出语句">shell printf命令：格式化输出语句</h2><h2 id="Shell_if_else语句">Shell if else语句</h2><p>if 语句通过关系运算符判断表达式的真假来决定执行哪个分支。Shell 有三种 if … else 语句：</p>
<ul>
<li>if … fi 语句；</li>
<li>if … else … fi 语句；</li>
<li>if … elif … else … fi 语句。</li>
</ul>
<h2 id="Shell_case_esac语句">Shell case esac语句</h2><blockquote>
<p>类似于其他语言的<code>switch...case</code>语句。</p>
</blockquote>
<h2 id="Shell_for循环">Shell for循环</h2><p>与其他编程语言类似，Shell支持for循环。</p>
<p>for循环一般格式为：</p>
<pre><code><span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表
<span class="keyword">do</span>
    <span class="built_in">command</span>1
    <span class="built_in">command</span>2
    ...
    <span class="built_in">command</span>N
<span class="keyword">done</span>
</code></pre><p><strong>列表</strong>是一组值（数字、字符串等）组成的序列，每个值通过空格分隔。每循环一次，就将列表中的下一个值赋给变量。</p>
<p>in 列表是可选的，如果不用它，for 循环使用命令行的位置参数。</p>
<p>例如，顺序输出当前列表中的数字：</p>
<pre><code><span class="keyword">for</span> loop in <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>
<span class="keyword">do</span>
    echo <span class="string">"The value is: $loop"</span>
done
</code></pre><p>运行结果：</p>
<pre><code>The <span class="keyword">value</span> <span class="keyword">is</span>: <span class="number">1</span>
The <span class="keyword">value</span> <span class="keyword">is</span>: <span class="number">2</span>
The <span class="keyword">value</span> <span class="keyword">is</span>: <span class="number">3</span>
The <span class="keyword">value</span> <span class="keyword">is</span>: <span class="number">4</span>
The <span class="keyword">value</span> <span class="keyword">is</span>: <span class="number">5</span>
</code></pre><p>显示主目录下以 .bash 开头的文件：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
<span class="keyword">for</span> FILE <span class="keyword">in</span> <span class="variable">$HOME</span>/.bash*
<span class="keyword">do</span>
   <span class="built_in">echo</span> <span class="variable">$FILE</span>
<span class="keyword">done</span>
</code></pre><p>运行结果：</p>
<pre><code>/root/<span class="class">.bash_history</span>
/root/<span class="class">.bash_logout</span>
/root/<span class="class">.bash_profile</span>
/root/.bashrc
</code></pre><h2 id="Shell_while循环">Shell while循环</h2><pre><code><span class="keyword">while</span> <span class="command"><span class="keyword">command</span></span>
<span class="comment">#该语言使用do和done来进行控制循环代码块</span>
<span class="built_in">do</span> 
   Statement(s) <span class="built_in">to</span> be executed <span class="keyword">if</span> <span class="command"><span class="keyword">command</span> <span class="title">is</span> <span class="title">true</span></span>
done
</code></pre><h2 id="Shell_until循环">Shell until循环</h2><p>until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候，也只是极少数情况下，until 循环更加有用。</p>
<p>until 循环格式为：</p>
<pre><code><span class="keyword">until</span> <span class="command"><span class="keyword">command</span></span>
<span class="built_in">do</span>
   Statement(s) <span class="built_in">to</span> be executed <span class="keyword">until</span> <span class="command"><span class="keyword">command</span> <span class="title">is</span> <span class="title">true</span></span>
done
</code></pre><p>command 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</p>
<p>例如，使用 until 命令输出 0 ~ 9 的数字：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
a=<span class="number">0</span>
until [ ! <span class="variable">$a</span> <span class="operator">-lt</span> <span class="number">10</span> ]
<span class="keyword">do</span>
   <span class="built_in">echo</span> <span class="variable">$a</span>
   a=`expr <span class="variable">$a</span> + <span class="number">1</span>`
<span class="keyword">done</span>
</code></pre><p>运行结果：</p>
<pre><code><span class="number">0</span>
<span class="number">1</span>
<span class="number">2</span>
<span class="number">3</span>
<span class="number">4</span>
<span class="number">5</span>
<span class="number">6</span>
<span class="number">7</span>
<span class="number">8</span>
<span class="number">9</span>
</code></pre><p>##　Shell break和continue命令</p>
<p>##　Shell函数：Shell函数返回值、删除函数、在终端调用函数</p>
<blockquote>
<p>函数可以让我们将一个复杂功能划分成若干模块，让程序结构更加清晰，代码重复利用率更高。像其他编程语言一样，Shell 也支持函数。Shell 函数必须先定义后使用。</p>
</blockquote>
<p>Shell 函数的定义格式如下：</p>
<pre><code><span class="keyword">function</span><span class="number">_n</span>ame () {
    list <span class="keyword">of</span> commands
    [ <span class="keyword">return</span> <span class="keyword">value</span> ]
}
</code></pre><p>如果你愿意，也可以在函数名前加上关键字 function：</p>
<pre><code><span class="keyword">function</span> <span class="keyword">function</span><span class="number">_n</span>ame () {
    list <span class="keyword">of</span> commands
    [ <span class="keyword">return</span> <span class="keyword">value</span> ]
}
</code></pre><p>函数返回值，可以显式增加<code>return</code>语句；如果不加，会将最后一条命令运行结果作为返回值。</p>
<p>Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。如果 return 其他数据，比如一个字符串，往往会得到错误提示：“numeric argument required”。</p>
<p>如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在需要的时候访问这个变量来获得函数返回值。</p>
<p>先来看一个例子：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
<span class="comment"># Define your function here</span>
<span class="function"><span class="title">Hello</span></span> () {
   <span class="built_in">echo</span> <span class="string">"Url is http://see.xidian.edu.cn/cpp/shell/"</span>
}
<span class="comment"># Invoke your function</span>
Hello
</code></pre><p>运行结果：</p>
<pre><code>$./<span class="keyword">test</span>.<span class="keyword">sh</span>
Hello World
$
</code></pre><p>调用函数只需要给出函数名，不需要加括号。</p>
<p>再来看一个带有return语句的函数：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
<span class="function"><span class="title">funWithReturn</span></span>(){
    <span class="built_in">echo</span> <span class="string">"The function is to get the sum of two numbers..."</span>
    <span class="built_in">echo</span> -n <span class="string">"Input first number: "</span>
    <span class="built_in">read</span> aNum
    <span class="built_in">echo</span> -n <span class="string">"Input another number: "</span>
    <span class="built_in">read</span> anotherNum
    <span class="built_in">echo</span> <span class="string">"The two numbers are <span class="variable">$aNum</span> and <span class="variable">$anotherNum</span> !"</span>
    <span class="built_in">return</span> $((<span class="variable">$aNum</span>+<span class="variable">$anotherNum</span>))
}
funWithReturn
<span class="comment"># Capture value returnd by last command</span>
ret=$?
<span class="built_in">echo</span> <span class="string">"The sum of two numbers is <span class="variable">$ret</span> !"</span>
</code></pre><p>运行结果：</p>
<pre><code>The function <span class="keyword">is</span> <span class="keyword">to</span> <span class="keyword">get</span> <span class="keyword">the</span> sum <span class="keyword">of</span> two numbers...
Input <span class="keyword">first</span> <span class="type">number</span>: <span class="number">25</span>
Input another <span class="type">number</span>: <span class="number">50</span>
The two numbers are <span class="number">25</span> <span class="keyword">and</span> <span class="number">50</span> !
The sum <span class="keyword">of</span> two numbers <span class="keyword">is</span> <span class="number">75</span> !
</code></pre><p>函数返回值在调用该函数后通过 $? 来获得。</p>
<p>再来看一个函数嵌套的例子：</p>
<pre><code><span class="shebang">#!/bin/bash
</span>
<span class="comment"># Calling one function from another</span>
<span class="function"><span class="title">number_one</span></span> () {
   <span class="built_in">echo</span> <span class="string">"Url_1 is http://see.xidian.edu.cn/cpp/shell/"</span>
   number_two
}

<span class="function"><span class="title">number_two</span></span> () {
   <span class="built_in">echo</span> <span class="string">"Url_2 is http://see.xidian.edu.cn/cpp/u/xitong/"</span>
}

number_one
</code></pre><p>运行结果：</p>
<pre><code>Url_1 <span class="keyword">is</span> http:<span class="comment">//see.xidian.edu.cn/cpp/shell/</span>
Url_2 <span class="keyword">is</span> http:<span class="comment">//see.xidian.edu.cn/cpp/u/xitong/</span>
</code></pre><p>像删除变量一样，删除函数也可以使用 unset 命令，不过要加上 .f 选项，如下所示：<br>$unset .f function_name<br>如果你希望直接从终端调用函数，可以将函数定义在主目录下的 .profile 文件，这样每次登录后，在命令提示符后面输入函数名字就可以立即调用。</p>
<h2 id="Shell输入输出重定向：Shell_Here_Document，/dev/null文件">Shell输入输出重定向：Shell Here Document，/dev/null文件</h2><h2 id="Shell文件包含">Shell文件包含</h2><p>像其他语言一样，Shell 也可以包含外部脚本，将外部脚本的内容合并到当前脚本。</p>
<p>Shell 中包含脚本可以使用：</p>
<pre><code><span class="bullet">. </span>filename
</code></pre><p>或</p>
<pre><code><span class="keyword">source</span> <span class="keyword">filename</span>
</code></pre><p>两种方式的效果相同，简单起见，一般使用点号(.)，但是注意点号(.)和文件名中间有一空格。</p>
<p>例如，创建两个脚本，一个是被调用脚本 subscript.sh，内容如下：</p>
<pre><code><span class="setting">url=<span class="value"><span class="string">"http://see.xidian.edu.cn/cpp/view/2738.html"</span></span></span>
</code></pre><p>一个是主文件 main.sh，内容如下：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
. ./subscript.sh
<span class="built_in">echo</span> <span class="variable">$url</span>
</code></pre><p>执行脚本：</p>
<pre><code><span class="variable">$chomd</span> +x main<span class="class">.sh</span>
./main<span class="class">.sh</span>
http:<span class="comment">//see.xidian.edu.cn/cpp/view/2738.html</span>
$
</code></pre><blockquote>
<p>注意：被包含脚本不需要有执行权限。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/数学和算法/Poj等价表达式/" itemprop="url">
                Poj等价表达式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/数学和算法/" itemprop="url" rel="index">
                  <span itemprop="name">数学和算法</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/数学和算法/Poj等价表达式/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/数学和算法/Poj等价表达式/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><strong>描述</strong><br>判断两个表达式在数学上是否是等价的。<br><strong>输入</strong><br>第一行：N（1&lt;=N&lt;=20），表示测试数据组数。<br>接下来每组测试数据包括两行，每行包括一个数学表达式，每个表达式的长度不超过80个字符。输入数据没有空行。</p>
<p><strong>一个表达式可能包括：</strong></p>
<ul>
<li>单个英文字母表示的变量（区分大小写）</li>
<li>数字（只有一位数）</li>
<li>配对的括号</li>
<li>运算符加+、减-、乘*</li>
<li>任意数量的空格或tab（可能出现在表达式中间的任何位置）</li>
</ul>
<blockquote>
<p>注意：表达式保证是语法正确的，且所有运算符的优先级相同，运算次序从左至右。变量的系数和指数保证不超过16位整数。</p>
</blockquote>
<p><strong>输出</strong><br>对每个测试数据，输出一行：等价则输出“YES”，不等价则输出“NO”。<br><em>样例输入</em></p>
<p>  3<br>  (a+b-c)<em>2<br>  (a+a)+(b</em>2)-(3<em>c)+c<br>  a</em>2-(a+c)+((a+c+e)<em>2)<br>  3</em>a+c+(2<em>e)<br>  (a-b)</em>(a-b)<br>  (a<em>a)-(2</em>a<em>b)-(b</em>b)</p>
<p><em>样例输出</em></p>
<p>  YES<br>  YES<br>  NO</p>
<h1 id="解题思路">解题思路</h1><hr>
<p>首先将计算式入栈，然后通过随机性的测试数据来进行检测两个式子代表的值是否相等。</p>
<p>栈、优先级、算式表达式、波兰表达式等。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/数学和算法/LeetCode/LeetCode-Two Sum/" itemprop="url">
                LeetCode-Two Sum
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/LeetCode/" itemprop="url" rel="index">
                  <span itemprop="name">LeetCode</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/数学和算法/LeetCode/LeetCode-Two Sum/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/数学和算法/LeetCode/LeetCode-Two Sum/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>Given an array of integers, find two numbers such that they add up to<br>a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that<br>they add up to the target, where index1 must be less than index2.<br>Please note that your returned answers (both index1 and index2) are<br>not zero-based.</p>
<p>You may assume that each input would have exactly one solution.</p>
<p><strong>Input</strong>: numbers={2, 7, 11, 15}, target=9<br><strong>Output</strong>: index1=1, index2=2</p>
</blockquote>
<hr>
<h3 id="Accepted_Code：">Accepted Code：</h3><pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {      
    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) {      
        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];      
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) {      
            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numbers.length; j++) {      
                <span class="keyword">if</span> (numbers[i] + numbers[j] == target) {      
                    a[<span class="number">0</span>] = i + <span class="number">1</span>;      
                    a[<span class="number">1</span>] = j + <span class="number">1</span>;
                    <span class="keyword">return</span> a;      
                }      
            }      
        }      
        <span class="keyword">return</span> a;      
    }
}
</code></pre><p>Problems:</p>
<ol>
<li>Time Limit Exceeded(超时)。</li>
</ol>
<p>Then:</p>
<pre><code><span class="keyword">if</span> (numbers[i] + numbers[j] == target) {
    a[<span class="number">0</span>] = i + <span class="number">1</span>;
    a[<span class="number">1</span>] = j + <span class="number">1</span>;
    <span class="keyword">return</span> a;<span class="comment">//this line is the Key Code.</span>
}
</code></pre><p><strong>省略计算不必要的结果，得到正确结果立刻返回。</strong></p>
<hr>
<p>Other Solution:</p>
<blockquote>
<p>代码是其他语言。</p>
</blockquote>
<p>题目大意：给一个数组，找出其中是否有两个数之和等于给定的值。类似的还有3 sum ，4 sum ..等 K sum 问题。其实原理是差不多的，这样想：先取出一个数，那么我只要在剩下的数字里面找到两个数字使得他们的和等于(target – 那个取出的数)。</p>
<p><strong>解法1：先排序，然后从开头和结尾同时向中间查找，原理也比较简单。复杂度O(nlogn)</strong></p>
<pre><code>typedef <span class="keyword">struct</span> <span class="type">Node</span>{    
    <span class="built_in">int</span> id,<span class="keyword">val</span>;
}<span class="type">Node</span>;

<span class="built_in">bool</span> compare(const <span class="type">Node</span> &amp;amp; a,const <span class="type">Node</span> &amp;amp; b){    
    return a.<span class="keyword">val</span> &lt; b.<span class="keyword">val</span>;
}

class <span class="type">Solution</span> {
    public:
    <span class="built_in">vector</span>&lt;<span class="built_in">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="built_in">int</span>&gt; &amp;amp;numbers, <span class="built_in">int</span> target){

        <span class="type">Node</span> nodes[numbers.size<span class="literal">()</span>];

        for(unsigned <span class="built_in">int</span> i=<span class="number">0</span>; i&lt;numbers.size<span class="literal">()</span>; i++){

        nodes[i].id = i+<span class="number">1</span>;

        nodes[i].<span class="keyword">val</span> = numbers[i];

    }
    sort(nodes, nodes+numbers.size<span class="literal">()</span>, compare);
    <span class="built_in">int</span> start=<span class="number">0</span>,<span class="keyword">end</span>=numbers.size<span class="literal">()</span>-<span class="number">1</span>;
    <span class="built_in">vector</span>&lt;<span class="built_in">int</span>&gt; ans;
    <span class="keyword">while</span>(start &lt; <span class="keyword">end</span>){

        <span class="keyword">if</span>(nodes[start].<span class="keyword">val</span> + nodes[<span class="keyword">end</span>].<span class="keyword">val</span> == target){

        <span class="keyword">if</span>(nodes[start].id &gt; nodes[<span class="keyword">end</span>].id)

        swap(nodes[start].id , nodes[<span class="keyword">end</span>].id);

        ans.push_back(nodes[start].id);

        ans.push_back(nodes[<span class="keyword">end</span>].id);

        return ans;

        }<span class="keyword">else</span> <span class="keyword">if</span>( nodes[start].<span class="keyword">val</span> + nodes[<span class="keyword">end</span>].<span class="keyword">val</span> &lt;target ){        
            start++;        
        } <span class="keyword">else</span>        
            <span class="keyword">end</span>--;
        }
    }
};
</code></pre><p><strong>解法2：使用HashMap。把每个数都存入map中，任何再逐个遍历，查找是否有 target – nubmers[i]。 时间复杂度 O(n)</strong></p>
<pre><code><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;numbers, <span class="keyword">int</span> target) {
        <span class="comment">// Start typing your C/C++ solution below</span>
        <span class="comment">// DO NOT write int main() function</span>
        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;
        <span class="keyword">int</span> length = numbers.size();
        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)
            mp[numbers[i]] = i;
        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it = mp.end();
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) {
            it = mp.find(target - numbers[i]);
            <span class="keyword">if</span>(it != mp.end()) {
                res.push_back(min(i+<span class="number">1</span>,it-&gt;second +<span class="number">1</span>));
                res.push_back(max(i+<span class="number">1</span>,it-&gt;second +<span class="number">1</span>));
                <span class="keyword">break</span>;
            }
        }
        <span class="keyword">return</span> res;
}
</code></pre><p>其实可以优化一下，因为题目只要求要到一个解，找到后即可返回。</p>
<pre><code><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;numbers, <span class="keyword">int</span> target) {
        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;
        <span class="keyword">int</span> length = numbers.size();
        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;
        <span class="keyword">int</span> find;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i){
            find=mp[target - numbers[i]];
            <span class="keyword">if</span>( find ){
                res.push_back(find);
                res.push_back(i+<span class="number">1</span>);
                <span class="keyword">break</span>;
            }
            mp[numbers[i]] = i+<span class="number">1</span>;
        }
        <span class="keyword">return</span> res;
}
</code></pre><hr>
<p>Java 版本解法：</p>
<p>Two Sum</p>
<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution.</p>
<p>思路：</p>
<p>先把原数组复制一遍，然后进行排序。在排序后的数组中找这两个数。最后再在原数组中找这两个数字的index即可。</p>
<p>时间复杂度O(nlogn)+O(n)+O(n) = O(nlogn)</p>
<p>注意的是结果有可能是两个数是相同的，比如 0 3 4 0, 0要返回1和4，不要返回成1和1或者4和4.</p>
<p>代码：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) {
    <span class="comment">// Start typing your Java solution below</span>
    <span class="comment">// DO NOT write main() function</span>
    <span class="comment">// Copy the original array and sort it</span>
    <span class="keyword">int</span> N = numbers.length;
    <span class="keyword">int</span>[] sorted = <span class="keyword">new</span> <span class="keyword">int</span>[N];
    System.arraycopy(numbers, <span class="number">0</span>, sorted, <span class="number">0</span>, N);
    Arrays.sort(sorted);
    <span class="comment">// find the two numbers using the sorted arrays</span>
    <span class="keyword">int</span> first = <span class="number">0</span>;
    <span class="keyword">int</span> second = sorted.length - <span class="number">1</span>;
    <span class="keyword">while</span> (first &lt; second) {

        <span class="keyword">if</span> (sorted[first] + sorted[second] &lt; target) {

            first++;

            <span class="keyword">continue</span>;

        }

        <span class="keyword">else</span> <span class="keyword">if</span> (sorted[first] + sorted[second] &gt; target) {

            second--;

            <span class="keyword">continue</span>;

        }

        <span class="keyword">else</span>
            <span class="keyword">break</span>;
    }
    <span class="keyword">int</span> number1 = sorted[first];
    <span class="keyword">int</span> number2 = sorted[second];
    <span class="comment">// Find the two indexes in the original array</span>
    <span class="keyword">int</span> index1 = -<span class="number">1</span>, index2 = -<span class="number">1</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) {

        <span class="keyword">if</span> ((numbers[i] == number1) || (numbers[i] == number2)) {

            <span class="keyword">if</span> (index1 == -<span class="number">1</span>)

                index1 = i + <span class="number">1</span>;

            <span class="keyword">else</span>

                index2 = i + <span class="number">1</span>;

        }

    }
    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[] { index1, index2 };
    Arrays.sort(result);
    <span class="keyword">return</span> result;
}
</code></pre><p>还有个无耻地利用hashmap的O(n)的算法，原理和暴力搜索没有本质区别，只不过hashmap的搜索速度是O(1)。</p>
<pre><code>public <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) {
    // <span class="type">Start</span> typing your <span class="type">Java</span> solution below
    // <span class="type">DO</span> <span class="type">NOT</span> write main() function

    <span class="type">HashMap</span>&lt;<span class="type">Integer</span>, <span class="type">Integer</span>&gt; map = new <span class="type">HashMap</span>&lt;<span class="type">Integer</span>, <span class="type">Integer</span>&gt;();

    <span class="type">int</span> n = numbers.length;

    <span class="type">int</span>[] <span class="literal">result</span> = new <span class="type">int</span>[<span class="number">2</span>];

    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) {
        <span class="keyword">if</span> (map.containsKey(target - numbers[i])) {
            <span class="literal">result</span>[<span class="number">0</span>] = map.get(target - numbers[i]) + <span class="number">1</span>;
            <span class="literal">result</span>[<span class="number">1</span>] = i + <span class="number">1</span>;
            <span class="keyword">break</span>;
        } <span class="keyword">else</span> {
            map.put(numbers[i], i);
        }
    }

    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>后记：你的想法很独特嘛。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/数学和算法/AES加密/" itemprop="url">
                AES加密
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/数学和算法/" itemprop="url" rel="index">
                  <span itemprop="name">数学和算法</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/数学和算法/AES加密/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/数学和算法/AES加密/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="加密的历程：">加密的历程：</h2><p>从 <strong>按规则替换</strong> -&gt; <strong>对称加密</strong> -&gt; <strong>非对称加密</strong> 的过程，看到加密技术的不断进化。</p>
<h3 id="破解方式：">破解方式：</h3><p>按规则替换：根据频率破解。<br>对称加密：截获密钥。<br>非对称加密：？？？    </p>
<h2 id="非对称加密：">非对称加密：</h2><p>非对称加密又称公开密钥加密。</p>
<blockquote>
<p>公开密钥加密（英语：public-key cryptography，又译为公开密钥加密），也称为非对称加密（asymmetric cryptography），一种密码学算法类型，在这种密码学方法中，需要一对密钥，一是个私人密钥，另一个则是公开密钥。这两个密钥是数学相关，用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密。如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。称公开的密钥为公钥；不公开的密钥为私钥。<br>–<strong>wiki</strong></p>
</blockquote>
<p>在非对称加密中使用的主要算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。</p>
<h3 id="优点">优点</h3><p>与对称密钥加密相比，优点在于无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。</p>
<h3 id="过程">过程</h3><p>假设两个用户A向B发送信息。B的公钥为c，对应私钥（也是属于B的）为d，明文为x.  </p>
<ol>
<li>A用公钥对明文进行加密形成密文c(x)，然后传输密文；  </li>
<li>B收到密文，用私钥对密文进行解密d(c(x)),得到要通信的明文x。<br>B向A发送信息反之。</li>
</ol>
<p>现在主要解释RSA加密原理。</p>
<hr>
<h2 id="原理">原理</h2><h3 id="互质关系">互质关系</h3><p>如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。</p>
<p>有以上，不难得到以下结论：  </p>
<ol>
<li>任意两个质数构成互质关系，比如13和61。  </li>
<li>一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。  </li>
<li>如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。  </li>
<li>1和任意一个自然数是都是互质关系，比如1和99。  </li>
<li>p是大于1的整数，则p和p-1构成互质关系，比如57和56。  </li>
<li>p是大于1的奇数，则p和p-2构成互质关系，比如17和15。  </li>
</ol>
<h3 id="欧拉函数">欧拉函数</h3><p>请思考一下问题：</p>
<blockquote>
<p>任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）<br>–阮一峰</p>
</blockquote>
<p>计算这个值的方法就叫做欧拉函数，以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。<br>φ(n) 的计算方法并不复杂，但是为了得到最后那个公式，需要一步步讨论。  </p>
<h4 id="第一种情况">第一种情况</h4><p>如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。</p>
<h4 id="第二种情况">第二种情况</h4><p>如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。</p>
<h4 id="第三种情况">第三种情况</h4><p>如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则<br>$$\phi(p^k)=p^k-p^{k-1}$$<br>比如 φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4。<br>这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p^(k-1)个，即1×p、2×p、3×p、…、p^(k-1)×p，把它们去除，剩下的就是与n互质的数。<br>上面的式子还可以写成下面的形式：<br>$$\phi(p^k)=p^k-p^{k-1}=p^k(1-\frac{1}{p})$$<br>可以看出，上面的第二种情况是 k=1 时的特例。</p>
<h4 id="第四种情况">第四种情况</h4><p>如果n可以分解成两个互质的整数之积，<br>$$n=p_1<em>p_2$$<br>则<br>$$\phi(n)=\phi(p_1p_2)=\phi(p_1)\phi(p_2)$$<br>即积的欧拉函数等于各个因子的欧拉函数之积。比如，<em>*φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24</em></em>。<br>这一条的证明要用到”中国剩余定理”，这里就不展开了，只简单说一下思路：如果a与p1互质(a&lt;p1)，b与p2互质(b&lt;p2)，c与p1p2互质(c&lt;p1p2)，则c与数对 (a,b) 是一一对应关系。由于a的值有φ(p1)种可能，b的值有φ(p2)种可能，则数对 (a,b) 有φ(p1)φ(p2)种可能，而c的值有φ(p1p2)种可能，所以φ(p1p2)就等于φ(p1)φ(p2)。</p>
<h4 id="第五种情况">第五种情况</h4><p>待续…</p>
<p>—未完待续：<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/思维改变生活/应该选择怎样一款笔记？/" itemprop="url">
                应该选择怎样一款笔记？
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/思维改变生活/" itemprop="url" rel="index">
                  <span itemprop="name">思维改变生活</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/思维改变生活/应该选择怎样一款笔记？/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/思维改变生活/应该选择怎样一款笔记？/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>随着知识的越来越多，需要认真收集和管理的知识也越来越多，管理的难度也越来越大，越来越力不从心。先看下选择历程吧。</p>
<h3 id="1-_选择历程">1. 选择历程</h3><h4 id="1-1_网页标签">1.1 网页标签</h4><p>首先是网页标签。首先是IE浏览器，在Win8时代开始可以同步网页书签了，然后使用了Chrome，同样是基于书签的知识收集，没有多少整理。</p>
<h4 id="1-2_Office_OneNote">1.2 Office OneNote</h4><p>在这个阶段整理了大部分的笔记。目前还是那里最多。</p>
<h4 id="1-3_WordPress_Typecho等博客程序">1.3 WordPress Typecho等博客程序</h4><p>内容也不是很多.</p>
<h4 id="1-4_微博标记、网易Lofter记录">1.4 微博标记、网易Lofter记录</h4><p>很少。优点是没有朋友圈，不会打扰到别人。</p>
<h4 id="1-5_Github和印象笔记">1.5 Github和印象笔记</h4><p>Github支持Markdown，但是没有方便的客户端，印象笔记的马克飞象又是收费的，哎，还要继续寻找。</p>
<h4 id="1-6_直到这里-&gt;为知笔记">1.6 直到这里-&gt;<em>为知笔记</em></h4><p>既支持Markdown又支持各种客户端，可以方便查阅，目前使用中。</p>
<h3 id="2-_对，其实我的要求很简单：">2. 对，其实我的要求很简单：</h3><ul>
<li>支持各种客户端，现在使用的有：Windows，Android和iOS</li>
<li>支持Markdown。我讨厌排版，调整字号。Markdown支持简单丰富易用的语法来实现层次逻辑和排版。对，它还支持<strong>程序代码</strong>！</li>
<li>必要时可以分享，即有公开链接。</li>
</ul>
<h3 id="3-_现在开始，认真梳理丰富自己的知识架构">3. 现在开始，认真梳理丰富自己的知识架构</h3></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/思维改变生活/利用暗时间/" itemprop="url">
                利用暗时间
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/思维改变生活/" itemprop="url" rel="index">
                  <span itemprop="name">思维改变生活</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/思维改变生活/利用暗时间/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/思维改变生活/利用暗时间/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>专注，才会把事情做好。</p>
<p>对比在学校中，工作的时候无疑是很多打扰人的事情，常常会使效率降低。</p>
<p>专注，就是将某种任务的CPU优先级提高，时刻提醒自己最重要的事情是什么。</p>
<p>流体验，很久没有这种感觉了。</p>
<p>记得自己的梦想，然后时刻调整自己的思想。</p>
<p>对，知乎会打开自己的思路；但是，也会占用大量时间，有时候这些时间用来思考更重要。</p>
<p>减少任务切换。</p>
<hr>
<p>充足的能量 保证思考所需。</p>
<p><a href="http://blog.csdn.net/chuanchuan608/article/details/17915959" target="_blank" rel="external">http://blog.csdn.net/chuanchuan608/article/details/17915959</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/知识记录/深入学习微框架：Spring Boot/" itemprop="url">
                深入学习微框架：Spring Boot
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/知识记录/" itemprop="url" rel="index">
                  <span itemprop="name">知识记录</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/知识记录/深入学习微框架：Spring Boot/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/知识记录/深入学习微框架：Spring Boot/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>转自：<a href="http://www.infoq.com/cn/articles/microframeworks1-spring-boot" target="_blank" rel="external">http://www.infoq.com/cn/articles/microframeworks1-spring-boot</a><br>参考视频：<a href="http://www.tudou.com/programs/view/gWhLS4wIvgU/" target="_blank" rel="external">http://www.tudou.com/programs/view/gWhLS4wIvgU/</a><br><a href="http://www.cnblogs.com/suncj/p/4065589.html" target="_blank" rel="external">http://www.cnblogs.com/suncj/p/4065589.html</a><br><a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-creating-and-dropping-jpa-databases" target="_blank" rel="external">http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-creating-and-dropping-jpa-databases</a><br><a href="http://www.infoq.com/cn/articles/microframeworks1-spring-boot" target="_blank" rel="external">http://www.infoq.com/cn/articles/microframeworks1-spring-boot</a></p>
<blockquote>
<p>@Query()使用HQL语句。Hibernate查询方式。</p>
</blockquote>
<p>SpringBoot的Pom文件简介</p>
<blockquote>
<p>HSQLDB是一个开放源代码的JAVA数据库</p>
</blockquote>
<p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而<strong>使开发人员不再需要定义样板化的配置</strong>。通过这种方式，Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。</p>
<p>多年以来，Spring IO平台饱受非议的一点就是<strong>大量的XML配置以及复杂的依赖管理</strong>。在去年的SpringOne 2GX会议上，Pivotal的CTO Adrian Colyer回应了这些批评，并且特别提到该平台将来的目标之一就是实现免XML配置的开发体验。Boot所实现的功能超出了这个任务的描述，开发人员不仅不再需要编写XML，而且在一些场景中甚至不需要编写繁琐的import语句。在对外公开的beta版本刚刚发布之时，<strong>Boot描述了如何使用该框架在140个字符内实现可运行的web应用，从而获得了极大的关注度，该样例发表在tweet上</strong>。</p>
<p>然而，Spring Boot并不是要成为Spring IO平台里面众多“Foundation”层项目的替代者。Spring Boot的目标不在于为已解决的问题域提供新的解决方案，而是<strong>为平台带来另一种开发体验</strong>，从而简化对这些已有技术的使用。对于已经熟悉Spring生态系统的开发人员来说，Boot是一个很理想的选择，不过对于采用Spring技术的新人来说，Boot提供一种更简洁的方式来使用这些技术。</p>
<p>在追求开发体验的提升方面，Spring Boot，甚至可以说整个Spring生态系统都使用到了Groovy编程语言。Boot所提供的众多便捷功能，都是借助于Groovy强大的MetaObject协议、可插拔的AST转换过程以及内置的依赖解决方案引擎所实现的。在其核心的编译模型之中，Boot使用Groovy来构建工程文件，所以它可以使用通用的导入和样板方法（如类的main方法）对类所生成的字节码进行装饰（decorate）。这样使用Boot编写的应用就能保持非常简洁，却依然可以提供众多的功能。</p>
<h3 id="安装Boot">安装Boot</h3><p>从最根本上来讲，<strong>Spring Boot就是一些库的集合</strong>，它能够被任意项目的构建系统所使用。简便起见，该框架也提供了命令行界面，它可以用来运行和测试Boot应用。框架的发布版本，包括集成的CLI（命令行界面），可以在Spring仓库中手动下载和安装。一种更为简便的方式是使用<strong>Groovy</strong>环境管理器（Groovy enVironment Manager，GVM），它会处理Boot版本的安装和管理。Boot及其CLI可以通过GVM的命令行gvm install springboot进行安装。在OS X上安装Boot可以使用Homebrew包管理器。为了完成安装，首先要使用brew tap pivotal/tap切换到Pivotal仓库中，然后执行brew install springboot命令。</p>
<p>要进行打包和分发的工程会依赖于像Maven或Gradle这样的构建系统。为了简化依赖图，Boot的功能是模块化的，通过导入Boot所谓的“starter”模块，可以将许多的依赖添加到工程之中。为了更容易地管理依赖版本和使用默认配置，框架提供了一个parent POM，工程可以继承它。Spring Boot工程的样例POM文件定义如程序清单1所示。</p>
<p>程序清单1</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">project</span> <span class="attribute">xmlns</span>=<span class="value">"http://maven.apache.org/POM/4.0.0"</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="title">modelVersion</span>&gt;</span>

    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>myproject<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="title">version</span>&gt;</span>

    <span class="comment">&lt;!-- Inherit defaults from Spring Boot --&gt;</span>
    <span class="tag">&lt;<span class="title">parent</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.0.RC1<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">parent</span>&gt;</span>

    <span class="comment">&lt;!-- Add typical dependencies for a web application --&gt;</span>
    <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span>
        <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span>

    <span class="tag">&lt;<span class="title">repositories</span>&gt;</span>
        <span class="tag">&lt;<span class="title">repository</span>&gt;</span>
            <span class="tag">&lt;<span class="title">id</span>&gt;</span>spring-snapshots<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
            <span class="tag">&lt;<span class="title">url</span>&gt;</span>http://repo.spring.io/libs-snapshot<span class="tag">&lt;/<span class="title">url</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">repository</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">repositories</span>&gt;</span>

    <span class="tag">&lt;<span class="title">pluginRepositories</span>&gt;</span>
        <span class="tag">&lt;<span class="title">pluginRepository</span>&gt;</span>
            <span class="tag">&lt;<span class="title">id</span>&gt;</span>spring-snapshots<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
            <span class="tag">&lt;<span class="title">url</span>&gt;</span>http://repo.spring.io/libs-snapshot<span class="tag">&lt;/<span class="title">url</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">pluginRepository</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">pluginRepositories</span>&gt;</span>

    <span class="tag">&lt;<span class="title">build</span>&gt;</span>
        <span class="tag">&lt;<span class="title">plugins</span>&gt;</span>
            <span class="tag">&lt;<span class="title">plugin</span>&gt;</span>
                <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
                <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">plugins</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">build</span>&gt;</span>
<span class="tag">&lt;/<span class="title">project</span>&gt;</span>
</code></pre><p>为了实现更为简单的构建配置，开发人员可以使用Gradle构建系统中简洁的Groovy DSL，如程序清单1.1所示。</p>
<p>程序清单1.1</p>
<pre><code><span class="keyword">buildscript</span> {
  <span class="keyword">repositories</span> {
    maven { url <span class="string">"http://repo.spring.io/libs-snapshot"</span> }
    mavenCentral()
  }
  <span class="keyword">dependencies</span> {
    <span class="keyword">classpath</span>(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:1.0.0.RC1"</span>)
  }
}

apply plugin: <span class="string">'java'</span>
apply plugin: <span class="string">'spring-boot'</span>
<span class="keyword">repositories</span> {
  mavenCentral()
  maven { url <span class="string">"http://repo.spring.io/libs-snapshot"</span>  }
}

<span class="keyword">dependencies</span> {
  <span class="keyword">compile</span> <span class="string">'org.springframework.boot:spring-boot-starter-actuator:1.0.0.RC1'</span>
}
</code></pre><p>为了快速地搭建和运行Boot工程，Pivotal提供了称之为“Spring Initializr” 的web界面，用于下载预先定义好的Maven或Gradle构建配置。我们也可以使用Lazybones模板实现快速起步，在执行lazybones create spring-boot-actuator my-app命令后，它会为Boot应用创建必要的工程结构以及gradle构建文件。</p>
<h3 id="开发Spring_Boot应用">开发Spring Boot应用</h3><p>Spring Boot在刚刚公开宣布之后就将一个样例发布到了Twitter上，它目前成为了最流行的一个应用样例。它的全部描述如程序清单1.2所示，一个非常简单的Groovy文件可以生成功能强大的以Spring为后端的web应用。</p>
<p>程序清单1.2</p>
<pre><code><span class="annotation">@RestController</span>
<span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{
  <span class="annotation">@RequestMapping</span>(<span class="string">"/"</span>)
  <span class="built_in">String</span> home() {
    <span class="string">"hello"</span>
  }
}
</code></pre><p>这个应用可以通过spring run App.groovy命令在Spring Boot CLI中运行。Boot会分析文件并根据各种“编译器自动配置（compiler auto-configuration）”标示符来确定其意图是生成Web应用。然后，它会在一个嵌入式的Tomcat中启动Spring应用上下文，并且使用默认的8080端口。打开浏览器并导航到给定的URL，随后将会加载一个页面并展现简单的文本响应：“hello”。提供默认应用上下文以及嵌入式容器的这些过程，能够让开发人员更加关注于开发应用以及业务逻辑，从而不用再关心繁琐的样板式配置。</p>
<p>Boot能够自动确定类所需的功能，这一点使其成为了强大的快速应用开发工具。当应用在Boot CLI中执行时，它们在使用内部的Groovy编译器进行构建，这个编译器可以在字节码生成的时候以编码的方式探查并修改类。通过这种方式，使用CLI的开发人员不仅可以省去定义默认配置，在一定程度上甚至可以不用定义特定的导入语句，它们可以在编译的过程中识别出来并自动进行添加。除此之外，当应用在CLI中运行时，Groovy内置的依赖管理器，“Grape”，将会解析编译期和运行时的类路径依赖，与Boot编译器的自动配置机制类似。这种方式不仅使得框架更加对用户友好，而且能够让不同版本的Spring Boot与特定版本的来自于Spring IO平台的库相匹配，这样一来开发人员就不用关心如何管理复杂的依赖图和版本结构了。另外，它还有助于快速原型的开发并生成概念原型的工程代码。</p>
<p><strong>对于不是使用CLI构建的工程，Boot提供了许多的“starter”模块，它们定义了一组依赖，这些依赖能够添加到构建系统之中，从而解析框架及其父平台所需的特定类库。</strong>例如，spring-boot-starter-actuator依赖会引入一组基本的Spring项目，从而实现应用的快速配置和即时可用。关于这种依赖，值得强调的一点就是当开发Web应用，尤其是RESTful Web服务的时候，如果包含了spring-boot-starter-web依赖，它就会为你提供启动嵌入式Tomcat容器的自动化配置，并且提供对微服务应用有价值的端点信息，如服务器信息、应用指标（metrics）以及环境详情。除此之外，如果引入spring-boot-starter-security模块的话，actuator会自动配置Spring Security，从而为应用提供基本的认证以及其他高级的安全特性。它还会为应用结构引入一个内部的审计框架，这个框架可以用来生成报告或其他的用途，比如开发认证失败的锁定策略。</p>
<p>为了阐述在Java Maven工程中，如何快速地使Spring Web工程准备就绪，考虑一下程序清单1.3中的应用程序代码。</p>
<p>程序清单1.3</p>
<pre><code><span class="keyword">package</span> com.infoq.springboot;

<span class="keyword">import</span> org.springframework.boot.SpringApplication;
<span class="keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;
<span class="keyword">import</span> org.springframework.web.bind.annotation.*;

<span class="annotation">@RestController</span>
<span class="annotation">@EnableAutoConfiguration</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>{

  <span class="annotation">@RequestMapping</span>(<span class="string">"/"</span>)
  <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="string">"Hello"</span>;
  }

  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
    SpringApplication.run(Application.class, args);
  }
}
</code></pre><p>在Application类上的@EnableAutoConfiguration注解会告知Boot要采用一种特定的方式来对应用进行配置。这种方法会将其他样板式的配置均假设为框架默认的约定，因此能够聚焦于如何尽快地使应用准备就绪以便运行起来。Application类是可运行的，因此，当我们以Java Application的方式运行这个类时，就能启动该应用及其嵌入式的容器，这样也能实现即时地开发。</p>
<p>为了发布版本而构建工程时，Boot的Maven和Gradle插件可以嵌入（hook）到这些构建系统的打包过程中，以生成可执行的“胖jar包（fat jar）”，这种jar包含了工程的所有依赖并且能够以可运行jar的方式执行。使用Maven打包Boot应用只需运行mvn package命令，与之类似，使用Gradle时，执行gradle build命令将会在构建的目标地址下生成可运行的jar。</p>
<p>开发微服务</p>
<p>Boot对Spring应用的开发进行了简化，提供了模块化方式导入依赖的能力，强调了开发RESTful Web服务的功能并提供了生成可运行jar的能力，这一切都清晰地表明在开发可部署的微服务方面Boot框架是一个强大的工具。正如前面的例子所示，借助于Boot，让一个RESTful Web工程运行起来是一件很容易的事情；不过，为了了解Boot所有潜在的功能，我们会阐述在开发完整功能的微服务时，会遇到的所有繁琐的事情。在企业级基础<strong>设施领域，微服务是一种越来越流行的应用架构，因为它能够实现快速开发、更小的代码库、企业级集成以及模块化部署。</strong>有众多的框架致力于该领域的开发，该章节将会讨论使用Boot如何简化这一过程。</p>
<h3 id="数据访问">数据访问</h3><p>我们可以基于各种目的来构建微服务，但有一点是肯定的，<strong>那就是大多数都需要读取和写入数据库的能力</strong>。Spring Boot使数据库集成变成了一项非常简单的任务，<strong>因为它具有自动配置Spring Data以访问数据库的能力</strong>。只需在你的工程中将<code>spring-boot-starter-data-jpa</code>包含进来，Boot的自动配置引擎就能探测到你的工程需要数据访问功能，并且会在Spring应用上下文中创建必要的Bean，这样你就可以使用Repository和服务了。为了更具体地阐述这一点，请参见程序清单1.4中的Gradle构建文件，它列出了一个基于Groovy的微服务web应用的构建结构，该应用使用了Spring Data对JPA的支持来实现数据访问。</p>
<p>程序清单1.4</p>
<pre><code><span class="keyword">buildscript</span> {
  <span class="keyword">repositories</span> {
    maven { url <span class="string">"http://repo.spring.io/libs-snapshot"</span> }
    mavenCentral()
  }
  <span class="keyword">dependencies</span> {
    <span class="keyword">classpath</span>(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:1.0.0.RC1"</span>)
  }
}

apply plugin: <span class="string">'groovy'</span>
apply plugin: <span class="string">'spring-boot'</span>

<span class="keyword">repositories</span> {
  mavenCentral()
  maven { url <span class="string">"http://repo.spring.io/libs-snapshot"</span>  }
}

ext {
  springBootVersion = <span class="string">"1.0.0.RC1"</span>
}

<span class="keyword">dependencies</span> {
  <span class="keyword">compile</span> <span class="string">'org.codehaus.groovy:groovy-all:2.2.1'</span>
  <span class="keyword">compile</span> <span class="string">"org.springframework.boot:spring-boot-starter-web:$springBootVersion"</span>
  <span class="keyword">compile</span> <span class="string">"org.springframework.boot:spring-boot-starter-data-jpa:$springBootVersion"</span>
  <span class="keyword">compile</span> <span class="string">"org.springframework.boot:spring-boot-starter-actuator:$springBootVersion"</span>
}
</code></pre><p>在这个配置中，Boot的actuator模块提供了对hsqldb的依赖，这会搭建所有必要的依赖——包括模式的创建——因此Spring Data可以使用这个内存数据库作为数据源。这种简便的方式能够让开发人员免于在开发期创建和管理复杂的XML配置，进而能够快速地开发数据库驱动的微服务。如果在classpath中有H2或Derby数据库的话，这种自动化配置也会生效。Boot所提供的另一个便利之处就是能够快速简便地使用相关数据启动应用的数据库模式。这在开发期是非常有用的，此时数据库可能是在内存中或者是不稳定的，开发人员需要保证的是在应用启动的时候能够访问到这些特定的数据。为了阐述这一点，考虑一下程序清单1.5中的示例JPA实体，它代表了微服务所提供的“User”数据结构。</p>
<p>程序清单1.5</p>
<pre><code><span class="variable">@Entity</span>
class User {
  <span class="variable">@Id</span>
  <span class="variable">@GeneratedValue</span>
  Long id

  String username
  String firstName
  String lastName
  Date createdDate
  Date lastAccessed

  Boolean isActive = Boolean.TRUE
}
</code></pre><p>为了启用代表User对象的通用数据，我们只需创建一个名为schema.sql或data.sql的文件，并将其包含在classpath之中。这个文件会在模式创建完成之后执行，所以基于程序清单1.5所给出的实体，我们可以使用SQL语句启用一个用户账号，如程序清单1.6所示。</p>
<p>程序清单1.6</p>
<pre><code>insert into <span class="function"><span class="title">user</span><span class="params">(username, first_name, last_name, created_date)</span></span> values (<span class="string">'danveloper'</span>, <span class="string">'Dan'</span>, <span class="string">'Woods'</span>, <span class="function"><span class="title">now</span><span class="params">()</span></span>)
</code></pre><p>在启动的时候，我们所提供的SQL代码会执行，这样就能确保有一个测试账号可以使用。微服务此时已经具有了数据访问的起始点，程序清单1.7展现了如何按照Spring Data的开发模式创建Repository接口，该接口会作为User实体的数据访问对象（Data Access Object）。</p>
<p>程序清单1.7</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>{
}
</code></pre><p>CrudRepository提供了一些通用的接口方法来创建、查询、更新以及删除对象和对象集合。应用所需的其他特定功能可以按照Spring Data的Repository开发约定进行定义。一旦UserRepository接口创建成功，Boot的spring-data-jpa层会在工程中探测到它，并将其添加到Spring应用上下文之中，这样对于controller和sevice对象来说，它就成为可以进行自动注入的可选对象。这种自动化的配置只有在Boot应用要求按照这种方式初始化的时候才生效，这是通过存在@EnableAutoConfiguration注解来标识的。借助程序清单1.8中所实现的controller，微服务现在就可以定义RESTful端点了，服务的使用者可以获取到User的列表或单个User。</p>
<p>程序清单1.8</p>
<pre><code><span class="annotation">@RestController</span>
<span class="annotation">@EnableAutoConfiguration</span>
<span class="annotation">@RequestMapping</span>(<span class="string">"/user"</span>)
<span class="class"><span class="keyword">class</span> <span class="title">UserController</span> {</span>

  <span class="annotation">@Autowired</span>
  UserRepository repository

  <span class="annotation">@RequestMapping</span>(method=[RequestMethod.GET])
  <span class="keyword">def</span> get(Long id) {
    id ? repository.findOne(id) : repository.findAll()
  }

  <span class="keyword">public</span> <span class="keyword">static</span> <span class="typename">void</span> main(String[] args) {
    SpringApplication.run UserController, args
  }
}
</code></pre><p>在启动的时候，应用将会输出日志，<strong>表明<code>Hibernate</code>按照User实体的定义创建数据库结构</strong>，在应用初始化的最后，Boot还会从schema.sql文件中导入数据。</p>
<p>在开发微服务应用时，需要特别注意的一点是使用了@RequestMapping注解。这不是Boot特定的注解。不过，因为Boot安装了自己的端点以监控应用的性能、健康情况以及配置，所以需要确保应用的代码不要与这些内置的提供详情的路径解析相冲突。鉴于此，如果有从请求路径中解析属性的需求（在我们的场景中，也就是user的id属性），那么我们需要仔细考虑这个动态的属性解析会对微服务的其他行为产生什么影响。在本例中，只是简单地将controller映射到/user端点而不是根上下文，就能允许Boot的端点也可以进行访问。</p>
<p>微服务所提供的数据并不一定全部适合关系型结构，针对这一点Spring Boot也暴露了一些模块，从而让开发人员可以使用Spring Data的MongoDB和Redis项目，不过依然采取特定的方式来进行配置。Spring Data用来定义数据访问对象（Data Access Object）的高层框架，这样快速切换JPA与非JPA数据源会变得非常容易。参见程序清单1.9，它展现了一个重新定义的UserRepository接口，这个接口设计为使用MongoDB取代JPA。</p>
<p>程序清单1.9</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>{
}
</code></pre><p>MongoRepository接口也扩展了CrudRepository，因此微服务的Controller代码，也就是程序清单1.8所示并不需要修改。为了实现与MongoDB的集成，工程唯一要做的就是在应用的classpath中包含spring-boot-starter-data-mongodb。程序清单1.4所示的Gradle构建文件需要稍微调整一下依赖的部分，如程序清单1.10所示。</p>
<p>程序清单1.10</p>
<pre><code><span class="keyword">dependencies</span> {
  <span class="keyword">compile</span> <span class="string">'org.codehaus.groovy:groovy-all:2.2.1'</span>
  <span class="keyword">compile</span> <span class="string">"org.springframework.boot:spring-boot-starter-web:$springBootVersion"</span>
  <span class="keyword">compile</span> <span class="string">"org.springframework.boot:spring-boot-starter-data-mongodb:$springBootVersion"</span>
  <span class="keyword">compile</span> <span class="string">"org.springframework.boot:spring-boot-starter-actuator:$springBootVersion"</span>
}
</code></pre><p>MongoDB依赖都置于classpath之中以后，Boot将会自动配置Spring Data连接到localhost上的数据库，并且默认的数据库名为test。在这个库中，将会自动创建User集合（按照MongoDB的标准），微服务现在就能使用MongoDB作为后端了。对非JPA的数据存储来说，初始化数据比其他的方式更为简单，这主要是因为它不能针对MongoDB的文档存储和Redis的键值存储运行SQL文件。鉴于Spring Data会使用这些存储的持久化实例，这就意味着开发期创建的数据需要在重启后保留。为了持久化数据，我们需要修改微服务的controller，这样服务的使用者就能创建User实例了。我们也可以将微服务的UserController进行修改，使其符合通用的RESTful API结构，让controller以不同的方式处理不同的HTTP方法。程序清单1.11展现了为controller添加创建新User实例的功能。</p>
<p>程序清单1.11</p>
<pre><code>@<span class="type">RestController</span>
@<span class="type">RequestMapping</span>(<span class="string">"/user"</span>)
@<span class="type">EnableAutoConfiguration</span>
class <span class="type">UserController</span> {

  @<span class="type">Autowired</span>
  <span class="type">UserRepository</span> repository

  @<span class="type">RequestMapping</span>(<span class="keyword">method</span>=[<span class="type">RequestMethod</span>.<span class="type">GET</span>])
  def get(<span class="type">Long</span> id) {
    id ? repository.findOne(id) : repository.findAll()
  }

  @<span class="type">RequestMapping</span>(<span class="keyword">method</span>=[<span class="type">RequestMethod</span>.<span class="type">POST</span>])
  def create(@<span class="type">RequestBody</span> <span class="type">User</span> user) {
    repository.save user
    user
  }

  public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) {
    <span class="type">SpringApplication</span>.run <span class="type">UserController</span>, args
  }
}
</code></pre><p>当微服务的使用者往应用的端点上发送一个HTTP POST请求时，Spring将会把请求体转换为User实例。代码接下来会使用UserRepository将这个对象存储到MongoDB集合之中。使用curl创建User实例的样例如程序清单1.12所示。</p>
<p>程序清单1.12</p>
<pre><code>curl -v -H "Content-Type: application/json" -d "<span class="special">{</span> <span class="command">\"</span>username<span class="command">\"</span>: <span class="command">\"</span>danveloper<span class="command">\"</span>, <span class="command">\"</span>firstName<span class="command">\"</span>: <span class="command">\"</span>Dan<span class="command">\"</span>, <span class="command">\"</span>lastName<span class="command">\"</span>: <span class="command">\"</span>Woods<span class="command">\"</span>, <span class="command">\"</span>createdDate<span class="command">\"</span>: <span class="command">\"</span>2014-02-02T00:00:00<span class="command">\"</span> <span class="special">}</span>" http://localhost:8080/user
</code></pre><p>按照Boot针对Mongo数据源的特定配置，新的User实例默认会持久化到本地Mongo实例的test数据库的user集合之中。如果我们打开web浏览器并对微服务发起一个HTTP GET请求，我们就能看到所创建的user存在于返回的列表之中。</p>
<p>配置</p>
<p>我们可以很快地重写Spring Boot的默认配置。默认情况下，应用的配置可以使用Java属性文件来进行定义，这个文件名为application.properties并且位于应用的classpath根目录下。<strong>不过，一种更好的方式是使用 YAML配置，它提供了结构化以及嵌套的配置。</strong>在应用的运行时类路径之中包含snakeyaml之后，你的工程就可以在application.yml文件中直接定义配置了。为了详述这一点，考虑程序清单1.13的示例YAML配置，这里列出了应用的嵌入式HTTP服务器（默认是Tomcat，也可选择Jetty）的各种设置项。</p>
<p>程序清单1.13</p>
<pre><code><span class="preprocessor"># Server settings (ServerProperties)</span>
server:
  port: <span class="number">8080</span>
  address: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>
  sessionTimeout: <span class="number">30</span>
  contextPath: /

  <span class="preprocessor"># Tomcat specifics</span>
  tomcat:
    accessLogEnabled: <span class="literal">false</span>
    protocolHeader: x-forwarded-proto
    remoteIpHeader: x-forwarded-<span class="keyword">for</span>
    basedir:
    backgroundProcessorDelay: <span class="number">30</span> <span class="preprocessor"># secs</span>
</code></pre><p>允许重写Boot的自动化配置，这一点能够使你的应用从原型转化为真正的产品，Boot使用相同的<strong>application.yml</strong>文件进行配置，这样就会非常容易。自动化配置的指令被设计的尽可能简短，所以当使用actuator构建微服务时，会安装一个配置属性的端点，也就是/configprops，当确定哪些指令需要重写时可以进行参考。如果我们的微服务要使用持久化数据源，如MySQL，那么只需将MySQL的Java驱动添加到运行时classpath中，然后在application.yml中添加必要的配置指令即可，如程序清单1.14所示。</p>
<p>程序清单1.14</p>
<pre><code><span class="attribute">spring</span>:
  <span class="attribute">datasource</span>:
    <span class="attribute">driverClassName</span>: com.mysql.jdbc.Driver
    <span class="attribute">url</span>: <span class="attribute">jdbc</span>:<span class="attribute">mysql</span>:<span class="comment">//localhost:3306/proddb</span>
    <span class="attribute">username</span>: root
    password
</code></pre><p>在一些场景下你可能需要更为灵活的配置，Boot允许你通过Java的系统属性（System properties）重写很多它的默认配置。例如，如果你的应用需要在部署到产品化环境中使用不同的数据库用户，那么username配置指令可以通过标准的Java系统属性传入到应用之中，而这需要切换到命令行中执行-Dspring.datasource.username=user。关于这一点更为现实的场景是云部署环境，如Cloud Foundry或Heroku，这些平台需要应用启动特定的HTTP端口，这一点通过操作系统的环境变量可以实现。Boot能够从系统属性继承得到配置，这样你的应用就可以在命令行中使用-Dserver.port=$PORT来得到HTTP端口。在开发微服务时，这是一种相当有用的特性，因为它可以让微服务应用运行在各种环境配置之中。</p>
<h3 id="外部化配置">外部化配置</h3><p>微服务必须要支持的很重要的一点就是<strong>外部化配置</strong>。这种配置可以包含任何的内容，从占位符信息到数据库配置等等，在初始规划和构建应用原型时，这是必须要考虑的架构内容。在Spring IO平台中，已经存在各种导入配置的策略，但是应用能够以多种方式使用配置所造成的后果往往是产生冗长的编码性耦合。</p>
<p>Boot一个很棒的特性在于它能管理外部化的配置并将其转换为对象结构，这个对象可以在整个应用上下文中使用。创建一个简单老式的Java/Groovy对象（Plain Old Java/Groovy Object），并使用@ConfigurationProperties注解，那么这个对象就能使用Boot配置结构中预先定义的name名下的配置项。更具体一点来讲，考虑一下程序清单1.15中的POGO，它能够得到application.key下的配置指令。</p>
<p>程序清单1.15</p>
<pre><code><span class="annotation">@ConfigurationProperties</span>(name = <span class="string">"application"</span>)
<span class="class"><span class="keyword">class</span> <span class="title">ApplicationProperties</span> </span>{
  <span class="built_in">String</span> name
  <span class="built_in">String</span> version
}
</code></pre><p><strong>当ApplicationProperties对象在Spring上下文中创建完成之后，Boot将会识别出它是一个配置对象，并且会按照运行时classpath之中application.properties或application.yml文件中的配置指令填充它的属性。</strong>因此，如果我们在微服务的application.yml文件中添加application内容区的话，如程序清单1.16所示，那么我们就可以在应用的其他部分以编程的方式访问这些配置指令。</p>
<p>程序清单1.16</p>
<pre><code><span class="type">application</span>:
  <span class="property">name</span>: sb-ms-custdepl
  <span class="property">version</span>: <span class="number">0.1</span>-CUSTOMER
</code></pre><p><strong>这些配置指令可以有各种用途，要访问这些指令的唯一要求就是代表它们的POJO/POGO必须是Spring应用上下文的成员。</strong> Boot能够将一个controller作为Spring Java配置对象，这样就能很容易地管理配置bean与应用上下文的集成，如程序清单1.17所示。</p>
<p>程序清单1.17</p>
<pre><code><span class="annotation">@RestController</span>
<span class="annotation">@Configuration</span>
<span class="annotation">@RequestMapping</span>(<span class="string">"/appinfo"</span>)
<span class="annotation">@EnableAutoConfiguration</span>
<span class="class"><span class="keyword">class</span> <span class="title">AppInfoController</span> </span>{

  <span class="annotation">@Autowired</span>
  ApplicationProperties applicationProperties

  <span class="annotation">@RequestMapping</span>(method=[RequestMethod.GET])
  <span class="function">def <span class="title">get</span><span class="params">()</span> </span>{
    [
      name: applicationProperties.name,
      version: applicationProperties.version
    ]
  }

  <span class="annotation">@Bean</span>
  <span class="function">ApplicationProperties <span class="title">applicationProperties</span><span class="params">()</span> </span>{
    <span class="keyword">new</span> ApplicationProperties()
  }

  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
    SpringApplication.run UserController, args
  }
}
</code></pre><p>程序清单1.17中的样例代码可能有些牵强，不过，即便是在更为复杂的场景下，如何使用Boot来访问应用特定配置的原则是相同的。<strong>配置类也支持嵌套式的对象图</strong>，这样来自于配置中的深层数据就能更便利地进行访问，也有了更好的语义。例如，如果我们想要得到的配置指令是application.根下的那些metrics key，那么可以在ApplicationProperties POGO中添加一个嵌套对象来表示这些值，如程序清单1.18所示。</p>
<p>程序清单1.18</p>
<pre><code><span class="annotation">@ConfigurationProperties</span>(name = <span class="string">"application"</span>)
<span class="class"><span class="keyword">class</span> <span class="title">ApplicationProperties</span> </span>{
  <span class="built_in">String</span> name
  <span class="built_in">String</span> version

  <span class="keyword">final</span> Metrics metrics = <span class="keyword">new</span> Metrics()

  <span class="literal">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Metrics</span> </span>{
    <span class="built_in">String</span> dbExecutionTimeKey
  }
}
</code></pre><p>现在，我们的application.yml文件可以如程序清单1.19所示，它在application.代码块中包含了metrics配置。</p>
<p>程序清单1.19</p>
<pre><code><span class="type">application</span>:
  <span class="property">name</span>: sb-ms-custdepl
  <span class="property">version</span>: <span class="number">0.1</span>-CUSTOMER
  metrics:
    dbExecutionTimeKey: user.<span class="keyword">get</span>.db.<span class="property">time</span>
</code></pre><p>当我们需要访问application.metrics.dbExecutionTimeKey的值时，能够以编程的方式通过ApplicationProperties对象来进行访问。</p>
<p>为了在整个应用之中使用application.properties或application.yml文件中的这些配置指令，我们并不是必须要将其转换为对象图。Boot也为Spring应用上下文提供了PropertySourcesPlaceholderConfiguration，这样的话，来自于application.properties或application.yml文件的指令或者来自于Java系统的重写属性都可以作为Spring属性占位符来使用。Spring的这种机制能够让你以一种特定的语法来为属性定义占位符值，如果Spring发现了占位符配置的话，就会用这个配置来进行填充。<strong>作为示例，我们可以在controller中使用@Value注解来直接访问application.metrics.dbExecutionTimeKey，如程序清单1.20所示。</strong></p>
<p>程序清单1.20</p>
<pre><code>@<span class="type">RestController</span>
@<span class="type">RequestMapping</span>(<span class="string">"/user"</span>)
@<span class="type">EnableAutoConfiguration</span>
class <span class="type">UserController</span> {

  @<span class="type">Autowired</span>
  <span class="type">UserRepository</span> repository

  @<span class="type">Autowired</span>
  <span class="type">GaugeService</span> gaugeService

  @<span class="type">Value</span>('${application.metrics.dbExecutionTimeKey}')
  <span class="type">String</span> dbExecutionKey

  @<span class="type">RequestMapping</span>(<span class="keyword">method</span>=[<span class="type">RequestMethod</span>.<span class="type">GET</span>])
  def get(<span class="type">Long</span> id) {
    def start = new <span class="type">Date</span>().time
    def <span class="literal">result</span> = id ? repository.findOne(id) : repository.findAll()
    gaugeService.submit dbExecutionKey, new <span class="type">Date</span>().time - start
    <span class="literal">result</span>
  }

  public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) {
    <span class="type">SpringApplication</span>.run <span class="type">UserController</span>, args
  }
}
</code></pre><p><strong>关于应用指标的报告，后面会有更为详细的介绍，但现在重要的一点在于，理解@Value注解如何与Spring属性占位符一起使用，使Boot能够自动注入值，从而满足这个微服务的特定配置需求。</strong></p>
<h3 id="安全">安全</h3><p>在微服务的开发中，对于完备安全场景的需求会持续增长。为了满足这种需求，Boot引入了强大完整的Spring Security，并且提供了自动配置的功能，以快速简便地启用安全层。只需在应用的classpath中包含spring-boot-starter-security模块就能使Boot引入一些安全特性，如跨站脚本防护（cross-site scripting protection）并且会添加头信息以防止点击劫持（click-jacking）。除此之外，添加一条简单的配置指令就能启用基本认证来保护你的应用，如程序清单1.21所示。</p>
<p>程序清单1.21</p>
<pre><code><span class="attribute">security</span>:
  <span class="attribute">basic</span>:
    <span class="attribute">enabled</span>: true
</code></pre><p>Boot会为你提供一个默认的用户账号user和默认角色USER，并且会在应用启动的时候在控制台上输出随机生成的密码。就像Boot的其他功能那样，对于内置的user账号，我们可以很容易地指定不同的用户名和密码（分别为“secured”和“foo”），这需要通过明确定义的配置指令来实现，如程序清单1.22所示。</p>
<p>程序清单1.22</p>
<pre><code><span class="attribute">security</span>:
  <span class="attribute">basic</span>:
    <span class="attribute">enabled</span>: true
  <span class="attribute">user</span>:
    <span class="attribute">name</span>: secured
    <span class="attribute">password</span>: foo
</code></pre><p>对于简单的内部应用或开发原型来说，Boot内置的基础设施能够快速地在微服务中启用基本认证，这是非常有用的。随着需求的演化，你的应用毫无疑问会需要更细粒度的安全特性，如保护端点只能由特定的角色访问。从这个角度来看，我们可能希望具有USER角色的调用者只能读取数据（即GET请求），而对具有ADMIN角色的调用者可以读取和写入数据（即POST请求）。为了做到这一点，我们需要在工程的application.yml文件中禁用Boot的基本认证自动配置功能，并且定义我们自己的user和admin账号以及对应的角色。当你的需求超过Boot所提供的默认功能时，它通常很快就能实现，这可以作为佐证这一点的又一个例子。为了更具体地阐述这一点，考虑一下程序清单1.23中的代码。这个样例可以阐述如何发挥Spring Security所有潜在的功能以及更为复杂的认证策略，如基于JDBC后端、OpenID或<strong>单点登录（Single-Sign On）。</strong></p>
<p>程序清单1.23</p>
<pre><code><span class="annotation">@RestController</span>
<span class="annotation">@RequestMapping</span>(<span class="string">"/user"</span>)
<span class="annotation">@Configuration</span>
<span class="annotation">@EnableGlobalMethodSecurity</span>(securedEnabled = <span class="literal">true</span>)
<span class="annotation">@EnableAutoConfiguration</span>
<span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">WebSecurityConfigurerAdapter</span> {</span>

  <span class="annotation">@Autowired</span>
  <span class="type">UserRepository</span> repository

  <span class="annotation">@RequestMapping</span>(method = [<span class="type">GET</span>])
  <span class="annotation">@Secured</span>([<span class="symbol">'ROLE_USE</span>R'])
  <span class="function"><span class="keyword">def</span> <span class="title">get</span>(</span><span class="type">Long</span> id) {
    <span class="comment">//这段代码写得很好，学习了。高度抽象</span>
    id ? repository.findOne(id) : repository.findAll()
  }

  <span class="annotation">@RequestMapping</span>(method = [<span class="type">POST</span>])
  <span class="annotation">@Secured</span>([<span class="symbol">'ROLE_ADMI</span>N'])
  <span class="function"><span class="keyword">def</span> <span class="title">create</span>(</span><span class="annotation">@RequestBody</span> <span class="type">User</span> user) {
    repository.save user
    user
  }

  <span class="annotation">@Override</span>
  void configure(<span class="type">AuthenticationManagerBuilder</span> auth) {
    auth
    .inMemoryAuthentication()
    .withUser <span class="string">"user"</span> password <span class="string">"password"</span> roles <span class="string">"USER"</span> and() withUser <span class="string">"admin"</span> password <span class="string">"password"</span> roles <span class="string">"USER"</span>, <span class="string">"ADMIN"</span>
  }

  <span class="annotation">@Override</span>
  void configure(<span class="type">HttpSecurity</span> http) <span class="keyword">throws</span> <span class="type">Exception</span> {
    <span class="type">BasicAuthenticationEntryPoint</span> entryPoint = <span class="keyword">new</span> <span class="type">BasicAuthenticationEntryPoint</span>()
    entryPoint.realmName = <span class="string">"Spring Boot"</span>
    http.exceptionHandling().authenticationEntryPoint(entryPoint)
    http.requestMatchers().antMatchers(<span class="string">"/**"</span>).anyRequest()
    .and().httpBasic().and().anonymous().disable().csrf().disable()
  }

  public static void main(<span class="type">String</span>[] args) {
    <span class="type">SpringApplication</span>.run <span class="type">UserController</span>, args
  }
}
</code></pre><p>在程序清单1.23的样例之中，应用现在被明确地配置为要基于user和admin用户账号进行访问，它们的密码都是password，具有的角色分别是USER和ADMIN。微服务的GET和POST端点分别通过USER和ADMIN角色进行保护，这就意味着普通用户可以访问只读的数据，而执行读取-写入操作的话，需要admin用户凭证。</p>
<p>对于微服务来说，基本认证是很好的一个选择，因为它遵循了很实用且广泛使用的认证协议。换句话说，很多的API调用者，包括移动应用，能够很容易地使用这一点来访问你的微服务。当你的认证需求超过了基本认证的功能时（如OpenID或OAuth），微服务可以使用Spring Security的全部功能来满足你的需求。</p>
<h3 id="消息集成">消息集成</h3><p>在任何的应用中，消息（messaging）都是一种很强大的工具，在一点上，微服务当然也不能例外。使用消息驱动架构开发的应用能够更好地支持可重用性和扩展性。Spring Boot能够让开发人员在编写微服务时将消息作为架构的核心组成部分，它使用到了Spring IO平台的企业集成模式（Enterprise Integration Patterns）实现，即Spring Integration。Spring Integration提供了开发消息驱动架构的基本结构，以及与分布式企业平台集成的模块。这种能力使得微服务可以使用来自抽象消息源的业务对象，这些消息源可以在应用内部，也可能是组织机构内部的其他服务所提供的。</p>
<p>尽管Boot并没有提供明确的Spring上下文自动化配置，但是它为Spring Integration提供了一个starter模块，它会负责引入Spring Integration项目的一系列依赖。这些依赖包括Spring Integration的核心库（Core library）、HTTP模块（用来进行面向HTTP的企业集成）、IP模块（用来进行基于Socket的集成操作）、File模块（用于进行文件系统集成）以及Stream模块（用于支持使用Stream的操作，如stdin和stdout）。这个starter模块为开发人员提供了健壮的消息功能的工具集，可以使已有的基础设施适应微服务API。</p>
<p>除了starter模块，Boot也为通过CLI构建的应用提供了编译器自动配置的功能。对于需要快速构建微服务原型并验证可行性的开发者来说，这种方式提供了一些捷径。使用企业级平台的应用可以快速地进行开发，在转移到正式的工程和构建系统之前，就能确认其价值。使用Spring Boot和Spring Integration使一个消息驱动的微服务运行起来非常简单，如程序清单1.24的样例代码所示。</p>
<p>程序清单1.24</p>
<pre><code><span class="variable">@RestController</span>
<span class="variable">@EnableIntegrationPatterns</span>
<span class="class"><span class="keyword">class</span> <span class="title">App</span> {</span>

  <span class="variable">@Bean</span>
  <span class="function"><span class="keyword">def</span> <span class="title">userLookupChannel</span><span class="params">()</span> {</span>
    new <span class="constant">DirectChannel</span>()
  }

  <span class="variable">@Bean</span>
  <span class="function"><span class="keyword">def</span> <span class="title">userTemplate</span><span class="params">()</span> {</span>
    new <span class="constant">MessagingTemplate</span>(userLookupChannel())
  }

  <span class="variable">@RequestMapping</span>(method=[<span class="constant">RequestMethod</span>.<span class="constant">GET</span>])
  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(<span class="variable">@RequestParam</span>(required=<span class="keyword">false</span>)</span> <span class="title">Long</span> <span class="title">id</span>) {</span>
    userTemplate().convertSendAndReceive( id ? id <span class="symbol">:</span> <span class="string">""</span>)
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">User</span> {</span>
  <span class="constant">Long</span> id
}

<span class="variable">@MessageEndpoint</span>
<span class="class"><span class="keyword">class</span> <span class="title">UserLookupObject</span> {</span>

  <span class="variable">@ServiceActivator</span>(inputChannel=<span class="string">"userLookupChannel"</span>)
  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(<span class="constant">Long</span> id)</span> {</span>
    id ? new <span class="constant">User</span>(<span class="symbol">id:</span>id) <span class="symbol">:</span> new <span class="constant">User</span>()
  }
}
</code></pre><p>使用消息驱动的方式来进行微服务的开发能提供很大的代码可重用性，并且能够与底层的服务提供者实现相解耦。在更为正式的场景之中，程序清单1.24的代码可能会负责组合数据，这些数据可能来自于数据库调用和企业组织中某个外部的服务集成。Spring Integration具有内置的设施用来进行负载路由（payload routing）和处理器链（handler chaining），这对于组合不同的数据来说，是一个很有吸引力的方案，我们的微服务可以作为一个数据的提供者（provider）。</p>
<h3 id="提供度量指标">提供度量指标</h3><p>微服务最重要的一个特性可能就是为报表终端（reporting agent）提供度量指标。不像那些功能完备的Web应用，微服务是轻量级的，设计时可能就不会规划提供报表界面或完备的接口来分析服务的活动。这种类型的操作最好是留给专门进行数据聚合和分析的应用，这些数据能够用来进行稳定性、性能以及商务智能的监控。基于这样的前提，微服务应该为这些工具提供端点，从而更加容易地获取有关该服务活动的数据。而报表工具负责将数据聚合到一个视图或报告中，对于关心数据的人这才是有意义的。</p>
<p>微服务的一些指标如稳定性和性能，对所有的应用都是通用的，但是与业务操作相关的指标必须由应用本身来具体进行管理。针对这一点，Spring Boot的actuator模块为开发人员提供了一种机制，允许开发人员通过/metrics端点以编码的方式暴露微服务状态的细节。Boot将指标拆分为“counter”和“gauge”两种类别：counter是所有以Number类型来展现的指标，而gauge是衡量双精度计算的指标。为了让微服务的开发人员更加容易地使用指标，Boot暴露了CounterService和GaugeService，它们可以自动织入到应用上下文之中。请参见程序清单1.25的样例，它阐述了如何通过CounterService对外暴露点击数。</p>
<p>程序清单1.25</p>
<pre><code>@<span class="type">RestController</span>
@<span class="type">RequestMapping</span>(<span class="string">"/user"</span>)
@<span class="type">EnableAutoConfiguration</span>
class <span class="type">UserController</span> {

  @<span class="type">Autowired</span>
  <span class="type">UserRepository</span> repository

  @<span class="type">Autowired</span>
  <span class="type">CounterService</span> counterService

  @<span class="type">RequestMapping</span>(<span class="keyword">method</span> = [<span class="type">GET</span>])
  def get() {
    get(null)
  }

  @<span class="type">RequestMapping</span>(value=<span class="string">"/{id}"</span>, <span class="keyword">method</span> = [<span class="type">GET</span>])
  def get(@<span class="type">PathVariable</span> <span class="type">Long</span> id) {
    counterService.increment id ? <span class="string">"queries.by.id.$id"</span> : <span class="string">"queries.without.id"</span>
    id ? repository.findOne(id) : repository.findAll()
  }
}
</code></pre><p>在点击/user端点时，有可能提供ID也有可能不提供ID，/metrics端点都会在counter.父节点下记录新的key。例如，如果我们只是查询/user端点而不带有ID的话，那么就会注册counter.queries.without.id指标。类似的，如果我们带有ID的话，那么就会看到有一个<code>counter.queries.by.id.&lt;id&gt;</code>的key，它能用来标记对于给定的ID已经进行了多少次查询。这些指标可能会有助于掌握最经常访问的User对象并指导要采取的行为，如缓存或数据库索引。类似于递增指标的数值，CounterService也允许将指标的值将为零。这对于跟踪打开的连接数或其他频率分布（histographic）的测量都是很有用处的。</p>
<p>gauge是稍微有所不同的一种类型指标，它会进行探索性的计算或基于请求来确定值。如GaugeService的JavaDocs所述，“gauge”可以测量任意的值，从方法执行的次数到会议室的温度。当需要为报表工具暴露细节时，这种类型的测量尤其适合于使用GaugeService。gauge的指标会在/metrics端点之下进行访问，并且带有gauge.前缀。它们的注册方式与counter有些差别，如程序清单1.26所示。</p>
<p>程序清单1.26</p>
<pre><code>@<span class="type">RestController</span>
@<span class="type">RequestMapping</span>(<span class="string">"/user"</span>)
@<span class="type">EnableAutoConfiguration</span>
class <span class="type">UserController</span> {

  @<span class="type">Autowired</span>
  <span class="type">UserRepository</span> repository

  @<span class="type">Autowired</span>
  <span class="type">CounterService</span> counterService

  @<span class="type">RequestMapping</span>(<span class="keyword">method</span> = [<span class="type">GET</span>])
  def get() {
    get(null)
  }

  @<span class="type">RequestMapping</span>(value=<span class="string">"/{id}"</span>, <span class="keyword">method</span> = [<span class="type">GET</span>])
  def get(@<span class="type">PathVariable</span> <span class="type">Long</span> id) {
    def start = new <span class="type">Date</span>().time
    def <span class="literal">result</span> = id ? repository.findOne(id) : repository.findAll()
    def time = new <span class="type">Date</span>().time - start
    gaugeService.submit(<span class="string">"user.get.db.time"</span>, time.doubleValue())
    <span class="literal">result</span>
  }
}
</code></pre><p>默认情况下，指标会存储在一个易失的内存数据库之中，但Boot同时也为应用上下文提供了MetricsRepository实现，它能支持更为持久化的行为。Boot自带了一个RedisMetricsRepository，它能够自动织入进来，从而将指标存储到Redis值存储之中，另外，可以编写自定义的实现将指标存储到任意的数据存储形式之中。</p>
<p>Boot还提供了对Coda Hale Metrics库的支持，它会将以特定名称开头的指标强制转换为对应的Metrics类型。例如，如果有一个指标是以histogram.开头，那么这个值将会作为Histogram对象类型。这种自动化的强制转换对于meter.和timer.key也是有效的，而普通的指标将会作为Gauge类型。</p>
<p>一旦微服务的指标在Boot中进行了注册，那么报表工具就可以通过/metrics端点来检索它们。已命名的指标可以通过/metrics端点获取，只需将指标的key名作为查询字符串的一部分即可。例如，如果只是访问gauge指标下的“user.get.db.time”，报表工具可以针对/metrics/gauge.user.get.db.time进行查询。</p>
<h3 id="打包Boot应用">打包Boot应用</h3><p>正如前面所讨论的，Boot提供了Maven和Gradle插件，它为构建系统的打包阶段提供了一种钩子（hook），以产生所谓的“胖jar”，在这种jar中包含了工程的所有依赖。当这个胖jar包执行时，应用将会运行在与工程开发期相同的嵌入式容器之中。这种简便的方式能够让开发人员省去很多麻烦，因为他们的部署包在开发期和运行时环境之中具有相同的依赖结构。这也能够缓解运维团队的焦虑，他们不用担心部署的场景，因为在部署时一个错误配置的运行时容器可能会带有某个特定的依赖，而在项目的开发期所依赖的可能是另外一个。</p>
<p>为了在Maven下执行打包，只需执行mvn package命令。Spring Boot的插件会备份工程所创建的原始jar并且在文件名上添加“.original”。在这里，能够得到可运行的jar，文件符合Maven artifact的命名约定，它可以按照工程最合适的方式进行部署。使用Gradle构建Boot工程同样很简单，只需执行标准的gradle build命令即可。类似于Maven，Boot插件在原有的打包任务之后使用Gradle安装了一个生命周期事件，并且会在build/libs目录下创建胖jar包。对所生成的胖jar包进行检查的一种方式就是所有依赖的jar都会位于归档文件的lib/目录下。</p>
<p>打包完成之后，胖jar包就能够像其他可运行的jar文件那样在命令行中执行了，也就是使用$JAVA_HOME/bin/java -jar path/to/myproject.jar命令。启动后，Boot应用的日志将会显示在控制台上。</p>
<p>对于需要部署到传统servlet容器之中的应用，Boot提供了一种方式以编码的方式初始化Web配置。为了使用这一点，Boot提供了可选的WebApplicationInitializer，它会使用servlet容器来注册应用，这会通过Servlet 3.0 API以编码的方式注册servlet并且会用到ServletContext。通过提供SpringBootServletInitializer的子类，Boot应用能够使用嵌入的Spring上下文来注册配置，这个Spring上下文是在容器初始化的时候创建的。为了阐述这个功能，考虑程序清单1.27中的示例代码。</p>
<p>程序清单1.27</p>
<pre><code><span class="annotation">@RestController</span>
<span class="annotation">@EnableAutoConfiguration</span>
<span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">SpringBootServletInitializer</span> {</span>

  <span class="annotation">@RequestMapping</span>(method = <span class="type">RequestMethod</span>.<span class="type">GET</span>)
  <span class="type">String</span> get() {
    <span class="string">"home"</span>
  }

  static void main(<span class="type">String</span>[] args) {
    <span class="type">SpringApplication</span>.run <span class="keyword">this</span>, args
  }

  <span class="annotation">@Override</span>
  <span class="type">SpringApplicationBuilder</span> configure(<span class="type">SpringApplicationBuilder</span> application) {
    application.sources <span class="type">Application</span>
  }
}
</code></pre><p>Application类中被重写的configure方法就是使用嵌入式的Spring上下文注册应用的地方。在更为正式的场景之中，这个方法可能会用来注册Spring Java配置类，它会定义应用中所有controller和服务的bean。</p>
<p>当将应用打包部署到servlet容器之中时，工程要构建为一个war文件。在Maven工程中，为了适应这一点，需要移除Boot插件，并且packaging需要明确定义为“war”类型，如程序清单1.28所示。</p>
<p>程序清单1.28</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">project</span> <span class="attribute">xmlns</span>=<span class="value">"http://maven.apache.org/POM/4.0.0"</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="title">modelVersion</span>&gt;</span>

    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>myproject<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;<span class="title">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="title">packaging</span>&gt;</span>

    <span class="tag">&lt;<span class="title">parent</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.0.RC1<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">parent</span>&gt;</span>

    <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span>
        <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span>

    <span class="tag">&lt;<span class="title">repositories</span>&gt;</span>
        <span class="tag">&lt;<span class="title">repository</span>&gt;</span>
            <span class="tag">&lt;<span class="title">id</span>&gt;</span>spring-snapshots<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
            <span class="tag">&lt;<span class="title">url</span>&gt;</span>http://repo.spring.io/libs-snapshot<span class="tag">&lt;/<span class="title">url</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">repository</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">repositories</span>&gt;</span>
<span class="tag">&lt;/<span class="title">project</span>&gt;</span>
</code></pre><p>对这个工程执行mvn install命令会在target目录下生成myproject-1.0.0-SNAPSHOT.war文件。使用Gradle构建的工程可以使用Gradle War Plugin，它为构建war文件暴露了一个war任务。类似于Maven的配置，Boot Gradle工程也需要移除所包含的Boot插件。产生war文件的示例Gradle构建脚本如程序清单1.29所示。</p>
<p>程序清单1.29</p>
<pre><code>apply plugin: <span class="string">'java'</span>
apply plugin: <span class="string">'war'</span>

repositories {
    mavenCentral()
    maven { url <span class="string">"http://repo.spring.io/snapshot"</span> }
    maven { url <span class="string">"http://repo.spring.io/milestone"</span> }
}

ext {
  springBootVersion = <span class="string">'1.0.0.BUILD-SNAPSHOT'</span>
}

dependencies {
    compile <span class="string">"org.springframework.boot:spring-boot-starter-web:${springBootVersion}"</span>
    compile <span class="string">"org.springframework.boot:spring-boot-starter-actuator:${springBootVersion}"</span>
}
</code></pre><p>对于Boot工程，使用这个构建脚本运行Gradle的war任务将会在build/libs目录下产生war文件。</p>
<p>不管是Maven还是Gradle的配置，一旦war文件产生，它就可以部署到任意兼容Servlet 3.0的应用服务器之中。部分兼容的容器包括Tomcat 7+、Jetty 8、Glassfish 3.x、JBoss AS 6.x/7.x以及Websphere 8.0。</p>
<hr>
<p><strong>延伸阅读 Spring</strong></p>
<blockquote>
<p>Boot团队已经编写了完整的指导和样例来阐述框架的功能。Blog文章、参考资料以及API文档都可以在Spring.IO网站上找到。项目的GitHub页面上可以找到示例的工程，更为具体的细节可以阅读Spring<br>Boot的参考手册。SpringSourceDev YouTube频道有一个关于Spring<br>Boot的webinar，它概述了这个项目的目标和功能。在去年在伦敦举行的Groovy &amp; Grails Exchange上，David<br>Dawson做了一个使用Spring Boot开发微服务的演讲。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/知识记录/Java基础/String相关类对比2/" itemprop="url">
                String相关类对比2
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Java基础/" itemprop="url" rel="index">
                  <span itemprop="name">Java基础</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/知识记录/Java基础/String相关类对比2/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/知识记录/Java基础/String相关类对比2/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且大量浪费有限的内存空间,StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象,StringBuffer和StringBuilder类功能基本相似.   </p>
<h3 id="1-_String_类">1. String 类</h3><p>String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且大量浪费有限的内存空间。   </p>
<pre><code>String <span class="operator">a</span> = <span class="string">"a"</span>;<span class="comment"> //假设a指向地址0x0001 </span>
<span class="operator">a</span> = <span class="string">"b"</span><span class="comment">;//重新赋值后a指向地址0x0002，但0x0001地址中保存的"a"依旧存在，但已经不再是a所指向的,a 已经指向了其它地址。 </span>
</code></pre><p>因此String的操作都是改变赋值地址而不是改变值操作。 </p>
<h3 id="2-_StringBuffer_类">2. StringBuffer 类</h3><p>StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。 每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量。 </p>
<pre><code><span class="built_in">StringBuffer</span> buf=<span class="keyword">new</span> <span class="built_in">StringBuffer</span>(); <span class="comment">//分配长16字节的字符缓冲区 </span>
<span class="built_in">StringBuffer</span> buf=<span class="keyword">new</span> <span class="built_in">StringBuffer</span>(<span class="number">512</span>); <span class="comment">//分配长512字节的字符缓冲区 </span>
<span class="built_in">StringBuffer</span> buf=<span class="keyword">new</span> <span class="built_in">StringBuffer</span>(<span class="string">"this is a test"</span>)<span class="comment">//在缓冲区中存放了字符串，并在后面预留了16字节的空缓冲区。 </span>
</code></pre><h3 id="3-StringBuffer">3.StringBuffer</h3><p>StringBuffer和StringBuilder类功能基本相似，主要区别在于StringBuffer类的方法是多线程、安全的，而StringBuilder不是线程安全的，相比而言，StringBuilder类会略微快一点。对于经常要改变值的字符串应该使用StringBuffer和StringBuilder类。 </p>
<h3 id="4-线程安全">4.线程安全</h3><ul>
<li>StringBuffer 线程安全   </li>
<li>StringBuilder 线程不安全 </li>
</ul>
<h3 id="5-速度">5.速度</h3><p>一般情况下,速度从快到慢:<strong>StringBuilder&gt;StringBuffer&gt;String</strong>,这种比较是相对的，不是绝对的。 </p>
<h3 id="6-总结">6.总结</h3><p>（1）.如果要操作少量的数据用 = String<br>（2）.<strong>单线程</strong>操作字符串缓冲区 下操作大量数据 = StringBuilder<br>（3）.<strong>多线程</strong>操作字符串缓冲区 下操作大量数据 = StringBuffer </p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/photo.jpg" alt="Coder_Roc" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Coder_Roc</p>
        </div>
        <p class="site-description motion-element" itemprop="description">诚信，认真，专注，踏实</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">48</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">63</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/cshijiel" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/cshijiel" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/cshijiel" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp;  2014 - 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Coder_Roc</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"usee"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
