<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="诚信，认真，专注，踏实" />



  <meta name="keywords" content="Java,互联网,NodeJS" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="诚信，认真，专注，踏实">
<meta property="og:type" content="website">
<meta property="og:title" content="Roc`s 随想录">
<meta property="og:url" content="http://coderroc.com/page/5/index.html">
<meta property="og:site_name" content="Roc`s 随想录">
<meta property="og:description" content="诚信，认真，专注，踏实">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Roc`s 随想录">
<meta name="twitter:description" content="诚信，认真，专注，踏实">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'hide'
  };
</script>

  <title> Roc`s 随想录 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Roc`s 随想录</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/知识记录/Linux基础/Linux Shell入门/" itemprop="url">
                Linux Shell入门
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Linux基础/" itemprop="url" rel="index">
                  <span itemprop="name">Linux基础</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/知识记录/Linux基础/Linux Shell入门/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/知识记录/Linux基础/Linux Shell入门/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="Shell简介：什么是Shell，Shell命令的两种执行方式">Shell简介：什么是Shell，Shell命令的两种执行方式</h2><p>Shell本身是一个用C语言编写的程序，它是用户使用Unix/Linux的桥梁，用户的大部分工作都是通过Shell完成的。Shell既是一种命令语言，又是一种程序设计语言。</p>
<p>可以说，shell使用的熟练程度反映了用户对Unix/Linux使用的熟练程度。</p>
<p><strong>Shell有两种执行命令的方式：</strong></p>
<ul>
<li>交互式（Interactive）：解释执行用户的命令，用户输入一条命令，Shell就解释执行一条。</li>
<li>批处理（Batch）：用户事先写一个Shell脚本(Script)，其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令。</li>
</ul>
<p>Shell脚本和编程语言很相似，<strong>也有变量和流程控制语句</strong>，但Shell脚本是解释执行的，不需要编译，Shell程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到Shell提示符下执行。</p>
<blockquote>
<p><em>Shell初学者请注意，在平常应用中，建议不要用 root 帐号运行 Shell 。作为普通用户，不管您有意还是无意，都无法破坏系统；但如果是 root，那就不同了，只要敲几个字母，就可能导致灾难性后果。</em></p>
</blockquote>
<h2 id="几种常见的Shell">几种常见的Shell</h2><p>Unix/Linux上常见的Shell脚本解释器有bash、sh、csh、ksh等，习惯上把它们称作一种Shell。我们常说有多少种Shell，其实说的是Shell脚本解释器。</p>
<p>其中：<code>sh</code><br>sh 由Steve Bourne开发，是Bourne Shell的缩写，sh 是Unix 标准默认的shell。</p>
<p>第一个Shell脚本（Shell的<code>HelloWorld</code>）<br>打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。</p>
<p>输入一些代码：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
<span class="built_in">echo</span> <span class="string">"Hello World !"</span>
</code></pre><p>“<code>#!</code>” 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell。echo命令用于向窗口输出文本。</p>
<p><strong>作为可执行程序</strong></p>
<p>将上面的代码保存为test.sh，并 cd 到相应目录：</p>
<pre><code>chmod +x ./<span class="keyword">test</span>.<span class="keyword">sh</span>  #使脚本具有执行权限
./<span class="keyword">test</span>.<span class="keyword">sh</span>  #执行脚本
</code></pre><p>注意，一定要写成<code>./test.sh</code>，而不是test.sh。运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，<strong>要用./test.sh告诉系统说，就在当前目录找。</strong></p>
<p>通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。</p>
<p>这里的”系统”，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。</p>
<p>再看一个例子。下面的脚本使用 <strong>read</strong> 命令从 stdin 获取输入并赋值给 PERSON 变量，最后在 stdout 上输出：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
<span class="comment"># Author : mozhiyan</span>
<span class="comment"># Copyright (c) http://see.xidian.edu.cn/cpp/linux/</span>
<span class="comment"># Script follows here:</span>
<span class="built_in">echo</span> <span class="string">"What is your name?"</span>
<span class="built_in">read</span> PERSON
<span class="built_in">echo</span> <span class="string">"Hello, <span class="variable">$PERSON</span>"</span>
</code></pre><p>运行脚本：</p>
<pre><code>chmod +x ./<span class="keyword">test</span>.<span class="keyword">sh</span>
$./<span class="keyword">test</span>.<span class="keyword">sh</span>
What is your name?
mozhiyan
Hello, mozhiyan
$
</code></pre><h2 id="Shell变量：Shell变量的定义、删除变量、只读变量、变量类型">Shell变量：Shell变量的定义、删除变量、只读变量、变量类型</h2><p><strong>定义变量</strong></p>
<p>定义变量时，变量名不加美元符号（$），如：</p>
<pre><code><span class="setting">variableName=<span class="value"><span class="string">"value"</span></span></span>
</code></pre><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p>
<ul>
<li>首个字符必须为字母（a-z，A-Z）。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>
</ul>
<p>变量定义举例：</p>
<pre><code><span class="setting">myUrl=<span class="value"><span class="string">"http://see.xidian.edu.cn/cpp/linux/"</span></span></span>
<span class="setting">myNum=<span class="value"><span class="number">100</span></span></span>
</code></pre><p><strong>使用变量</strong><br>使用一个定义过的变量，只要在变量名前面加美元符号（<code>$</code>）即可，如：</p>
<pre><code>your_name=<span class="string">"mozhiyan"</span>
echo <span class="variable">$your</span>_name
echo ${your_name}
</code></pre><p>变量名外面的花括号是<strong>可选的</strong>，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p>
<pre><code><span class="keyword">for</span> skill <span class="keyword">in</span> Ada Coffe Action Java 
<span class="keyword">do</span>
    <span class="built_in">echo</span> <span class="string">"I am good at <span class="variable">${skill}</span>Script"</span>
<span class="keyword">done</span>
</code></pre><p>如果不给skill变量加花括号，写成</p>
<pre><code><span class="built_in">echo</span> <span class="string">"I am good at <span class="variable">$skillScript</span>"</span>`
</code></pre><p>解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p>
<blockquote>
<p>推荐给所有变量加上花括号，这是个好的编程习惯。</p>
</blockquote>
<p><strong>重新定义变量</strong></p>
<p><strong>只读变量</strong></p>
<pre><code><span class="built_in">readonly</span> myUrl
</code></pre><p><strong>删除变量</strong></p>
<pre><code><span class="built_in">unset</span> variable_name
</code></pre><p><strong>变量类型</strong></p>
<p>运行shell时，会同时存在三种变量：</p>
<ol>
<li><p><strong>局部变量</strong><br>局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</p>
</li>
<li><p><strong>环境变量</strong><br>所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</p>
</li>
<li><strong>shell变量</strong><br>shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>
</ol>
<h2 id="Shell特殊变量：Shell_$0,_$#,_$*,_$@,_$?,_$$和命令行参数">Shell特殊变量：Shell $0, $#, $*, $@, $?, $$和命令行参数</h2><h2 id="Shell替换：Shell变量替换，命令替换，转义字符">Shell替换：Shell变量替换，命令替换，转义字符</h2><h2 id="Shell运算符：Shell算数运算符、关系运算符、布尔运算符、字符串运算符等">Shell运算符：Shell算数运算符、关系运算符、布尔运算符、字符串运算符等</h2><pre><code><span class="keyword">if</span> [ <span class="variable">$a</span> -le <span class="variable">$b</span> ]
<span class="keyword">then</span>
   echo <span class="string">"$a -le $b: a is less or  equal to b"</span>
<span class="keyword">else</span>
   echo <span class="string">"$a -le $b: a is not less or equal to b"</span>
fi
</code></pre><h2 id="Shell字符串">Shell字符串</h2><ul>
<li>单引号（原样输出）</li>
<li>双引号（可以转义、变量等）</li>
<li>拼接字符串</li>
<li>获取字符串长度</li>
<li>提取字符串</li>
<li>查找字符串</li>
</ul>
<h2 id="Shell数组：shell数组的定义、数组长度">Shell数组：shell数组的定义、数组长度</h2><ul>
<li>定义数组</li>
<li>读取数组</li>
<li>获取数组的长度</li>
</ul>
<h2 id="Shell_echo命令">Shell echo命令</h2><h2 id="shell_printf命令：格式化输出语句">shell printf命令：格式化输出语句</h2><h2 id="Shell_if_else语句">Shell if else语句</h2><p>if 语句通过关系运算符判断表达式的真假来决定执行哪个分支。Shell 有三种 if … else 语句：</p>
<ul>
<li>if … fi 语句；</li>
<li>if … else … fi 语句；</li>
<li>if … elif … else … fi 语句。</li>
</ul>
<h2 id="Shell_case_esac语句">Shell case esac语句</h2><blockquote>
<p>类似于其他语言的<code>switch...case</code>语句。</p>
</blockquote>
<h2 id="Shell_for循环">Shell for循环</h2><p>与其他编程语言类似，Shell支持for循环。</p>
<p>for循环一般格式为：</p>
<pre><code><span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表
<span class="keyword">do</span>
    <span class="built_in">command</span>1
    <span class="built_in">command</span>2
    ...
    <span class="built_in">command</span>N
<span class="keyword">done</span>
</code></pre><p><strong>列表</strong>是一组值（数字、字符串等）组成的序列，每个值通过空格分隔。每循环一次，就将列表中的下一个值赋给变量。</p>
<p>in 列表是可选的，如果不用它，for 循环使用命令行的位置参数。</p>
<p>例如，顺序输出当前列表中的数字：</p>
<pre><code><span class="keyword">for</span> loop in <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>
<span class="keyword">do</span>
    echo <span class="string">"The value is: $loop"</span>
done
</code></pre><p>运行结果：</p>
<pre><code>The <span class="keyword">value</span> <span class="keyword">is</span>: <span class="number">1</span>
The <span class="keyword">value</span> <span class="keyword">is</span>: <span class="number">2</span>
The <span class="keyword">value</span> <span class="keyword">is</span>: <span class="number">3</span>
The <span class="keyword">value</span> <span class="keyword">is</span>: <span class="number">4</span>
The <span class="keyword">value</span> <span class="keyword">is</span>: <span class="number">5</span>
</code></pre><p>显示主目录下以 .bash 开头的文件：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
<span class="keyword">for</span> FILE <span class="keyword">in</span> <span class="variable">$HOME</span>/.bash*
<span class="keyword">do</span>
   <span class="built_in">echo</span> <span class="variable">$FILE</span>
<span class="keyword">done</span>
</code></pre><p>运行结果：</p>
<pre><code>/root/<span class="class">.bash_history</span>
/root/<span class="class">.bash_logout</span>
/root/<span class="class">.bash_profile</span>
/root/.bashrc
</code></pre><h2 id="Shell_while循环">Shell while循环</h2><pre><code><span class="keyword">while</span> <span class="command"><span class="keyword">command</span></span>
<span class="comment">#该语言使用do和done来进行控制循环代码块</span>
<span class="built_in">do</span> 
   Statement(s) <span class="built_in">to</span> be executed <span class="keyword">if</span> <span class="command"><span class="keyword">command</span> <span class="title">is</span> <span class="title">true</span></span>
done
</code></pre><h2 id="Shell_until循环">Shell until循环</h2><p>until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候，也只是极少数情况下，until 循环更加有用。</p>
<p>until 循环格式为：</p>
<pre><code><span class="keyword">until</span> <span class="command"><span class="keyword">command</span></span>
<span class="built_in">do</span>
   Statement(s) <span class="built_in">to</span> be executed <span class="keyword">until</span> <span class="command"><span class="keyword">command</span> <span class="title">is</span> <span class="title">true</span></span>
done
</code></pre><p>command 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</p>
<p>例如，使用 until 命令输出 0 ~ 9 的数字：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
a=<span class="number">0</span>
until [ ! <span class="variable">$a</span> <span class="operator">-lt</span> <span class="number">10</span> ]
<span class="keyword">do</span>
   <span class="built_in">echo</span> <span class="variable">$a</span>
   a=`expr <span class="variable">$a</span> + <span class="number">1</span>`
<span class="keyword">done</span>
</code></pre><p>运行结果：</p>
<pre><code><span class="number">0</span>
<span class="number">1</span>
<span class="number">2</span>
<span class="number">3</span>
<span class="number">4</span>
<span class="number">5</span>
<span class="number">6</span>
<span class="number">7</span>
<span class="number">8</span>
<span class="number">9</span>
</code></pre><p>##　Shell break和continue命令</p>
<p>##　Shell函数：Shell函数返回值、删除函数、在终端调用函数</p>
<blockquote>
<p>函数可以让我们将一个复杂功能划分成若干模块，让程序结构更加清晰，代码重复利用率更高。像其他编程语言一样，Shell 也支持函数。Shell 函数必须先定义后使用。</p>
</blockquote>
<p>Shell 函数的定义格式如下：</p>
<pre><code><span class="keyword">function</span><span class="number">_n</span>ame () {
    list <span class="keyword">of</span> commands
    [ <span class="keyword">return</span> <span class="keyword">value</span> ]
}
</code></pre><p>如果你愿意，也可以在函数名前加上关键字 function：</p>
<pre><code><span class="keyword">function</span> <span class="keyword">function</span><span class="number">_n</span>ame () {
    list <span class="keyword">of</span> commands
    [ <span class="keyword">return</span> <span class="keyword">value</span> ]
}
</code></pre><p>函数返回值，可以显式增加<code>return</code>语句；如果不加，会将最后一条命令运行结果作为返回值。</p>
<p>Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。如果 return 其他数据，比如一个字符串，往往会得到错误提示：“numeric argument required”。</p>
<p>如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在需要的时候访问这个变量来获得函数返回值。</p>
<p>先来看一个例子：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
<span class="comment"># Define your function here</span>
<span class="function"><span class="title">Hello</span></span> () {
   <span class="built_in">echo</span> <span class="string">"Url is http://see.xidian.edu.cn/cpp/shell/"</span>
}
<span class="comment"># Invoke your function</span>
Hello
</code></pre><p>运行结果：</p>
<pre><code>$./<span class="keyword">test</span>.<span class="keyword">sh</span>
Hello World
$
</code></pre><p>调用函数只需要给出函数名，不需要加括号。</p>
<p>再来看一个带有return语句的函数：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
<span class="function"><span class="title">funWithReturn</span></span>(){
    <span class="built_in">echo</span> <span class="string">"The function is to get the sum of two numbers..."</span>
    <span class="built_in">echo</span> -n <span class="string">"Input first number: "</span>
    <span class="built_in">read</span> aNum
    <span class="built_in">echo</span> -n <span class="string">"Input another number: "</span>
    <span class="built_in">read</span> anotherNum
    <span class="built_in">echo</span> <span class="string">"The two numbers are <span class="variable">$aNum</span> and <span class="variable">$anotherNum</span> !"</span>
    <span class="built_in">return</span> $((<span class="variable">$aNum</span>+<span class="variable">$anotherNum</span>))
}
funWithReturn
<span class="comment"># Capture value returnd by last command</span>
ret=$?
<span class="built_in">echo</span> <span class="string">"The sum of two numbers is <span class="variable">$ret</span> !"</span>
</code></pre><p>运行结果：</p>
<pre><code>The function <span class="keyword">is</span> <span class="keyword">to</span> <span class="keyword">get</span> <span class="keyword">the</span> sum <span class="keyword">of</span> two numbers...
Input <span class="keyword">first</span> <span class="type">number</span>: <span class="number">25</span>
Input another <span class="type">number</span>: <span class="number">50</span>
The two numbers are <span class="number">25</span> <span class="keyword">and</span> <span class="number">50</span> !
The sum <span class="keyword">of</span> two numbers <span class="keyword">is</span> <span class="number">75</span> !
</code></pre><p>函数返回值在调用该函数后通过 $? 来获得。</p>
<p>再来看一个函数嵌套的例子：</p>
<pre><code><span class="shebang">#!/bin/bash
</span>
<span class="comment"># Calling one function from another</span>
<span class="function"><span class="title">number_one</span></span> () {
   <span class="built_in">echo</span> <span class="string">"Url_1 is http://see.xidian.edu.cn/cpp/shell/"</span>
   number_two
}

<span class="function"><span class="title">number_two</span></span> () {
   <span class="built_in">echo</span> <span class="string">"Url_2 is http://see.xidian.edu.cn/cpp/u/xitong/"</span>
}

number_one
</code></pre><p>运行结果：</p>
<pre><code>Url_1 <span class="keyword">is</span> http:<span class="comment">//see.xidian.edu.cn/cpp/shell/</span>
Url_2 <span class="keyword">is</span> http:<span class="comment">//see.xidian.edu.cn/cpp/u/xitong/</span>
</code></pre><p>像删除变量一样，删除函数也可以使用 unset 命令，不过要加上 .f 选项，如下所示：<br>$unset .f function_name<br>如果你希望直接从终端调用函数，可以将函数定义在主目录下的 .profile 文件，这样每次登录后，在命令提示符后面输入函数名字就可以立即调用。</p>
<h2 id="Shell输入输出重定向：Shell_Here_Document，/dev/null文件">Shell输入输出重定向：Shell Here Document，/dev/null文件</h2><h2 id="Shell文件包含">Shell文件包含</h2><p>像其他语言一样，Shell 也可以包含外部脚本，将外部脚本的内容合并到当前脚本。</p>
<p>Shell 中包含脚本可以使用：</p>
<pre><code><span class="bullet">. </span>filename
</code></pre><p>或</p>
<pre><code><span class="keyword">source</span> <span class="keyword">filename</span>
</code></pre><p>两种方式的效果相同，简单起见，一般使用点号(.)，但是注意点号(.)和文件名中间有一空格。</p>
<p>例如，创建两个脚本，一个是被调用脚本 subscript.sh，内容如下：</p>
<pre><code><span class="setting">url=<span class="value"><span class="string">"http://see.xidian.edu.cn/cpp/view/2738.html"</span></span></span>
</code></pre><p>一个是主文件 main.sh，内容如下：</p>
<pre><code><span class="shebang">#!/bin/bash</span>
. ./subscript.sh
<span class="built_in">echo</span> <span class="variable">$url</span>
</code></pre><p>执行脚本：</p>
<pre><code><span class="variable">$chomd</span> +x main<span class="class">.sh</span>
./main<span class="class">.sh</span>
http:<span class="comment">//see.xidian.edu.cn/cpp/view/2738.html</span>
$
</code></pre><blockquote>
<p>注意：被包含脚本不需要有执行权限。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/数学和算法/Poj等价表达式/" itemprop="url">
                Poj等价表达式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/数学和算法/" itemprop="url" rel="index">
                  <span itemprop="name">数学和算法</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/数学和算法/Poj等价表达式/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/数学和算法/Poj等价表达式/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><strong>描述</strong><br>判断两个表达式在数学上是否是等价的。<br><strong>输入</strong><br>第一行：N（1&lt;=N&lt;=20），表示测试数据组数。<br>接下来每组测试数据包括两行，每行包括一个数学表达式，每个表达式的长度不超过80个字符。输入数据没有空行。</p>
<p><strong>一个表达式可能包括：</strong></p>
<ul>
<li>单个英文字母表示的变量（区分大小写）</li>
<li>数字（只有一位数）</li>
<li>配对的括号</li>
<li>运算符加+、减-、乘*</li>
<li>任意数量的空格或tab（可能出现在表达式中间的任何位置）</li>
</ul>
<blockquote>
<p>注意：表达式保证是语法正确的，且所有运算符的优先级相同，运算次序从左至右。变量的系数和指数保证不超过16位整数。</p>
</blockquote>
<p><strong>输出</strong><br>对每个测试数据，输出一行：等价则输出“YES”，不等价则输出“NO”。<br><em>样例输入</em></p>
<p>  3<br>  (a+b-c)<em>2<br>  (a+a)+(b</em>2)-(3<em>c)+c<br>  a</em>2-(a+c)+((a+c+e)<em>2)<br>  3</em>a+c+(2<em>e)<br>  (a-b)</em>(a-b)<br>  (a<em>a)-(2</em>a<em>b)-(b</em>b)</p>
<p><em>样例输出</em></p>
<p>  YES<br>  YES<br>  NO</p>
<h1 id="解题思路">解题思路</h1><hr>
<p>首先将计算式入栈，然后通过随机性的测试数据来进行检测两个式子代表的值是否相等。</p>
<p>栈、优先级、算式表达式、波兰表达式等。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/数学和算法/LeetCode/LeetCode-Two Sum/" itemprop="url">
                LeetCode-Two Sum
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/LeetCode/" itemprop="url" rel="index">
                  <span itemprop="name">LeetCode</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/数学和算法/LeetCode/LeetCode-Two Sum/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/数学和算法/LeetCode/LeetCode-Two Sum/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>Given an array of integers, find two numbers such that they add up to<br>a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that<br>they add up to the target, where index1 must be less than index2.<br>Please note that your returned answers (both index1 and index2) are<br>not zero-based.</p>
<p>You may assume that each input would have exactly one solution.</p>
<p><strong>Input</strong>: numbers={2, 7, 11, 15}, target=9<br><strong>Output</strong>: index1=1, index2=2</p>
</blockquote>
<hr>
<h3 id="Accepted_Code：">Accepted Code：</h3><pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {      
    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) {      
        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];      
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) {      
            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numbers.length; j++) {      
                <span class="keyword">if</span> (numbers[i] + numbers[j] == target) {      
                    a[<span class="number">0</span>] = i + <span class="number">1</span>;      
                    a[<span class="number">1</span>] = j + <span class="number">1</span>;
                    <span class="keyword">return</span> a;      
                }      
            }      
        }      
        <span class="keyword">return</span> a;      
    }
}
</code></pre><p>Problems:</p>
<ol>
<li>Time Limit Exceeded(超时)。</li>
</ol>
<p>Then:</p>
<pre><code><span class="keyword">if</span> (numbers[i] + numbers[j] == target) {
    a[<span class="number">0</span>] = i + <span class="number">1</span>;
    a[<span class="number">1</span>] = j + <span class="number">1</span>;
    <span class="keyword">return</span> a;<span class="comment">//this line is the Key Code.</span>
}
</code></pre><p><strong>省略计算不必要的结果，得到正确结果立刻返回。</strong></p>
<hr>
<p>Other Solution:</p>
<blockquote>
<p>代码是其他语言。</p>
</blockquote>
<p>题目大意：给一个数组，找出其中是否有两个数之和等于给定的值。类似的还有3 sum ，4 sum ..等 K sum 问题。其实原理是差不多的，这样想：先取出一个数，那么我只要在剩下的数字里面找到两个数字使得他们的和等于(target – 那个取出的数)。</p>
<p><strong>解法1：先排序，然后从开头和结尾同时向中间查找，原理也比较简单。复杂度O(nlogn)</strong></p>
<pre><code>typedef <span class="keyword">struct</span> <span class="type">Node</span>{    
    <span class="built_in">int</span> id,<span class="keyword">val</span>;
}<span class="type">Node</span>;

<span class="built_in">bool</span> compare(const <span class="type">Node</span> &amp;amp; a,const <span class="type">Node</span> &amp;amp; b){    
    return a.<span class="keyword">val</span> &lt; b.<span class="keyword">val</span>;
}

class <span class="type">Solution</span> {
    public:
    <span class="built_in">vector</span>&lt;<span class="built_in">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="built_in">int</span>&gt; &amp;amp;numbers, <span class="built_in">int</span> target){

        <span class="type">Node</span> nodes[numbers.size<span class="literal">()</span>];

        for(unsigned <span class="built_in">int</span> i=<span class="number">0</span>; i&lt;numbers.size<span class="literal">()</span>; i++){

        nodes[i].id = i+<span class="number">1</span>;

        nodes[i].<span class="keyword">val</span> = numbers[i];

    }
    sort(nodes, nodes+numbers.size<span class="literal">()</span>, compare);
    <span class="built_in">int</span> start=<span class="number">0</span>,<span class="keyword">end</span>=numbers.size<span class="literal">()</span>-<span class="number">1</span>;
    <span class="built_in">vector</span>&lt;<span class="built_in">int</span>&gt; ans;
    <span class="keyword">while</span>(start &lt; <span class="keyword">end</span>){

        <span class="keyword">if</span>(nodes[start].<span class="keyword">val</span> + nodes[<span class="keyword">end</span>].<span class="keyword">val</span> == target){

        <span class="keyword">if</span>(nodes[start].id &gt; nodes[<span class="keyword">end</span>].id)

        swap(nodes[start].id , nodes[<span class="keyword">end</span>].id);

        ans.push_back(nodes[start].id);

        ans.push_back(nodes[<span class="keyword">end</span>].id);

        return ans;

        }<span class="keyword">else</span> <span class="keyword">if</span>( nodes[start].<span class="keyword">val</span> + nodes[<span class="keyword">end</span>].<span class="keyword">val</span> &lt;target ){        
            start++;        
        } <span class="keyword">else</span>        
            <span class="keyword">end</span>--;
        }
    }
};
</code></pre><p><strong>解法2：使用HashMap。把每个数都存入map中，任何再逐个遍历，查找是否有 target – nubmers[i]。 时间复杂度 O(n)</strong></p>
<pre><code><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;numbers, <span class="keyword">int</span> target) {
        <span class="comment">// Start typing your C/C++ solution below</span>
        <span class="comment">// DO NOT write int main() function</span>
        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;
        <span class="keyword">int</span> length = numbers.size();
        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)
            mp[numbers[i]] = i;
        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it = mp.end();
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) {
            it = mp.find(target - numbers[i]);
            <span class="keyword">if</span>(it != mp.end()) {
                res.push_back(min(i+<span class="number">1</span>,it-&gt;second +<span class="number">1</span>));
                res.push_back(max(i+<span class="number">1</span>,it-&gt;second +<span class="number">1</span>));
                <span class="keyword">break</span>;
            }
        }
        <span class="keyword">return</span> res;
}
</code></pre><p>其实可以优化一下，因为题目只要求要到一个解，找到后即可返回。</p>
<pre><code><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;numbers, <span class="keyword">int</span> target) {
        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;
        <span class="keyword">int</span> length = numbers.size();
        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;
        <span class="keyword">int</span> find;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i){
            find=mp[target - numbers[i]];
            <span class="keyword">if</span>( find ){
                res.push_back(find);
                res.push_back(i+<span class="number">1</span>);
                <span class="keyword">break</span>;
            }
            mp[numbers[i]] = i+<span class="number">1</span>;
        }
        <span class="keyword">return</span> res;
}
</code></pre><hr>
<p>Java 版本解法：</p>
<p>Two Sum</p>
<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution.</p>
<p>思路：</p>
<p>先把原数组复制一遍，然后进行排序。在排序后的数组中找这两个数。最后再在原数组中找这两个数字的index即可。</p>
<p>时间复杂度O(nlogn)+O(n)+O(n) = O(nlogn)</p>
<p>注意的是结果有可能是两个数是相同的，比如 0 3 4 0, 0要返回1和4，不要返回成1和1或者4和4.</p>
<p>代码：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) {
    <span class="comment">// Start typing your Java solution below</span>
    <span class="comment">// DO NOT write main() function</span>
    <span class="comment">// Copy the original array and sort it</span>
    <span class="keyword">int</span> N = numbers.length;
    <span class="keyword">int</span>[] sorted = <span class="keyword">new</span> <span class="keyword">int</span>[N];
    System.arraycopy(numbers, <span class="number">0</span>, sorted, <span class="number">0</span>, N);
    Arrays.sort(sorted);
    <span class="comment">// find the two numbers using the sorted arrays</span>
    <span class="keyword">int</span> first = <span class="number">0</span>;
    <span class="keyword">int</span> second = sorted.length - <span class="number">1</span>;
    <span class="keyword">while</span> (first &lt; second) {

        <span class="keyword">if</span> (sorted[first] + sorted[second] &lt; target) {

            first++;

            <span class="keyword">continue</span>;

        }

        <span class="keyword">else</span> <span class="keyword">if</span> (sorted[first] + sorted[second] &gt; target) {

            second--;

            <span class="keyword">continue</span>;

        }

        <span class="keyword">else</span>
            <span class="keyword">break</span>;
    }
    <span class="keyword">int</span> number1 = sorted[first];
    <span class="keyword">int</span> number2 = sorted[second];
    <span class="comment">// Find the two indexes in the original array</span>
    <span class="keyword">int</span> index1 = -<span class="number">1</span>, index2 = -<span class="number">1</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) {

        <span class="keyword">if</span> ((numbers[i] == number1) || (numbers[i] == number2)) {

            <span class="keyword">if</span> (index1 == -<span class="number">1</span>)

                index1 = i + <span class="number">1</span>;

            <span class="keyword">else</span>

                index2 = i + <span class="number">1</span>;

        }

    }
    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[] { index1, index2 };
    Arrays.sort(result);
    <span class="keyword">return</span> result;
}
</code></pre><p>还有个无耻地利用hashmap的O(n)的算法，原理和暴力搜索没有本质区别，只不过hashmap的搜索速度是O(1)。</p>
<pre><code>public <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) {
    // <span class="type">Start</span> typing your <span class="type">Java</span> solution below
    // <span class="type">DO</span> <span class="type">NOT</span> write main() function

    <span class="type">HashMap</span>&lt;<span class="type">Integer</span>, <span class="type">Integer</span>&gt; map = new <span class="type">HashMap</span>&lt;<span class="type">Integer</span>, <span class="type">Integer</span>&gt;();

    <span class="type">int</span> n = numbers.length;

    <span class="type">int</span>[] <span class="literal">result</span> = new <span class="type">int</span>[<span class="number">2</span>];

    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) {
        <span class="keyword">if</span> (map.containsKey(target - numbers[i])) {
            <span class="literal">result</span>[<span class="number">0</span>] = map.get(target - numbers[i]) + <span class="number">1</span>;
            <span class="literal">result</span>[<span class="number">1</span>] = i + <span class="number">1</span>;
            <span class="keyword">break</span>;
        } <span class="keyword">else</span> {
            map.put(numbers[i], i);
        }
    }

    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>后记：你的想法很独特嘛。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/数学和算法/AES加密/" itemprop="url">
                AES加密
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/数学和算法/" itemprop="url" rel="index">
                  <span itemprop="name">数学和算法</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/数学和算法/AES加密/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/数学和算法/AES加密/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="加密的历程：">加密的历程：</h2><p>从 <strong>按规则替换</strong> -&gt; <strong>对称加密</strong> -&gt; <strong>非对称加密</strong> 的过程，看到加密技术的不断进化。</p>
<h3 id="破解方式：">破解方式：</h3><p>按规则替换：根据频率破解。<br>对称加密：截获密钥。<br>非对称加密：？？？    </p>
<h2 id="非对称加密：">非对称加密：</h2><p>非对称加密又称公开密钥加密。</p>
<blockquote>
<p>公开密钥加密（英语：public-key cryptography，又译为公开密钥加密），也称为非对称加密（asymmetric cryptography），一种密码学算法类型，在这种密码学方法中，需要一对密钥，一是个私人密钥，另一个则是公开密钥。这两个密钥是数学相关，用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密。如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。称公开的密钥为公钥；不公开的密钥为私钥。<br>–<strong>wiki</strong></p>
</blockquote>
<p>在非对称加密中使用的主要算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。</p>
<h3 id="优点">优点</h3><p>与对称密钥加密相比，优点在于无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。</p>
<h3 id="过程">过程</h3><p>假设两个用户A向B发送信息。B的公钥为c，对应私钥（也是属于B的）为d，明文为x.  </p>
<ol>
<li>A用公钥对明文进行加密形成密文c(x)，然后传输密文；  </li>
<li>B收到密文，用私钥对密文进行解密d(c(x)),得到要通信的明文x。<br>B向A发送信息反之。</li>
</ol>
<p>现在主要解释RSA加密原理。</p>
<hr>
<h2 id="原理">原理</h2><h3 id="互质关系">互质关系</h3><p>如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。</p>
<p>有以上，不难得到以下结论：  </p>
<ol>
<li>任意两个质数构成互质关系，比如13和61。  </li>
<li>一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。  </li>
<li>如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。  </li>
<li>1和任意一个自然数是都是互质关系，比如1和99。  </li>
<li>p是大于1的整数，则p和p-1构成互质关系，比如57和56。  </li>
<li>p是大于1的奇数，则p和p-2构成互质关系，比如17和15。  </li>
</ol>
<h3 id="欧拉函数">欧拉函数</h3><p>请思考一下问题：</p>
<blockquote>
<p>任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）<br>–阮一峰</p>
</blockquote>
<p>计算这个值的方法就叫做欧拉函数，以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。<br>φ(n) 的计算方法并不复杂，但是为了得到最后那个公式，需要一步步讨论。  </p>
<h4 id="第一种情况">第一种情况</h4><p>如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。</p>
<h4 id="第二种情况">第二种情况</h4><p>如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。</p>
<h4 id="第三种情况">第三种情况</h4><p>如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则<br>$$\phi(p^k)=p^k-p^{k-1}$$<br>比如 φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4。<br>这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p^(k-1)个，即1×p、2×p、3×p、…、p^(k-1)×p，把它们去除，剩下的就是与n互质的数。<br>上面的式子还可以写成下面的形式：<br>$$\phi(p^k)=p^k-p^{k-1}=p^k(1-\frac{1}{p})$$<br>可以看出，上面的第二种情况是 k=1 时的特例。</p>
<h4 id="第四种情况">第四种情况</h4><p>如果n可以分解成两个互质的整数之积，<br>$$n=p_1<em>p_2$$<br>则<br>$$\phi(n)=\phi(p_1p_2)=\phi(p_1)\phi(p_2)$$<br>即积的欧拉函数等于各个因子的欧拉函数之积。比如，<em>*φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24</em></em>。<br>这一条的证明要用到”中国剩余定理”，这里就不展开了，只简单说一下思路：如果a与p1互质(a&lt;p1)，b与p2互质(b&lt;p2)，c与p1p2互质(c&lt;p1p2)，则c与数对 (a,b) 是一一对应关系。由于a的值有φ(p1)种可能，b的值有φ(p2)种可能，则数对 (a,b) 有φ(p1)φ(p2)种可能，而c的值有φ(p1p2)种可能，所以φ(p1p2)就等于φ(p1)φ(p2)。</p>
<h4 id="第五种情况">第五种情况</h4><p>待续…</p>
<p>—未完待续：<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/思维改变生活/应该选择怎样一款笔记？/" itemprop="url">
                应该选择怎样一款笔记？
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/思维改变生活/" itemprop="url" rel="index">
                  <span itemprop="name">思维改变生活</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/思维改变生活/应该选择怎样一款笔记？/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/思维改变生活/应该选择怎样一款笔记？/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>随着知识的越来越多，需要认真收集和管理的知识也越来越多，管理的难度也越来越大，越来越力不从心。先看下选择历程吧。</p>
<h3 id="1-_选择历程">1. 选择历程</h3><h4 id="1-1_网页标签">1.1 网页标签</h4><p>首先是网页标签。首先是IE浏览器，在Win8时代开始可以同步网页书签了，然后使用了Chrome，同样是基于书签的知识收集，没有多少整理。</p>
<h4 id="1-2_Office_OneNote">1.2 Office OneNote</h4><p>在这个阶段整理了大部分的笔记。目前还是那里最多。</p>
<h4 id="1-3_WordPress_Typecho等博客程序">1.3 WordPress Typecho等博客程序</h4><p>内容也不是很多.</p>
<h4 id="1-4_微博标记、网易Lofter记录">1.4 微博标记、网易Lofter记录</h4><p>很少。优点是没有朋友圈，不会打扰到别人。</p>
<h4 id="1-5_Github和印象笔记">1.5 Github和印象笔记</h4><p>Github支持Markdown，但是没有方便的客户端，印象笔记的马克飞象又是收费的，哎，还要继续寻找。</p>
<h4 id="1-6_直到这里-&gt;为知笔记">1.6 直到这里-&gt;<em>为知笔记</em></h4><p>既支持Markdown又支持各种客户端，可以方便查阅，目前使用中。</p>
<h3 id="2-_对，其实我的要求很简单：">2. 对，其实我的要求很简单：</h3><ul>
<li>支持各种客户端，现在使用的有：Windows，Android和iOS</li>
<li>支持Markdown。我讨厌排版，调整字号。Markdown支持简单丰富易用的语法来实现层次逻辑和排版。对，它还支持<strong>程序代码</strong>！</li>
<li>必要时可以分享，即有公开链接。</li>
</ul>
<h3 id="3-_现在开始，认真梳理丰富自己的知识架构">3. 现在开始，认真梳理丰富自己的知识架构</h3></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/思维改变生活/利用暗时间/" itemprop="url">
                利用暗时间
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/思维改变生活/" itemprop="url" rel="index">
                  <span itemprop="name">思维改变生活</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/思维改变生活/利用暗时间/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/思维改变生活/利用暗时间/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>专注，才会把事情做好。</p>
<p>对比在学校中，工作的时候无疑是很多打扰人的事情，常常会使效率降低。</p>
<p>专注，就是将某种任务的CPU优先级提高，时刻提醒自己最重要的事情是什么。</p>
<p>流体验，很久没有这种感觉了。</p>
<p>记得自己的梦想，然后时刻调整自己的思想。</p>
<p>对，知乎会打开自己的思路；但是，也会占用大量时间，有时候这些时间用来思考更重要。</p>
<p>减少任务切换。</p>
<hr>
<p>充足的能量 保证思考所需。</p>
<p><a href="http://blog.csdn.net/chuanchuan608/article/details/17915959" target="_blank" rel="external">http://blog.csdn.net/chuanchuan608/article/details/17915959</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/知识记录/Java基础/Thread类与多线程/" itemprop="url">
                Thread类与多线程
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Java基础/" itemprop="url" rel="index">
                  <span itemprop="name">Java基础</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/知识记录/Java基础/Thread类与多线程/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/知识记录/Java基础/Thread类与多线程/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>首先是ThreadA类，继承了Thread，重写了run().</p>
<pre><code><span class="keyword">package</span> cn.wiz.roc.thread;

public <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Thread</span> {</span>
    public <span class="type">ThreadA</span>(<span class="type">String</span> name) {
        <span class="keyword">super</span>(name);
    }

    public synchronized void run() {
        <span class="keyword">try</span> {
            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {
                <span class="type">System</span>.out.println(<span class="keyword">this</span>.getName() + <span class="string">":"</span> + i);
                <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)
                    <span class="comment">//每隔3的时候线程休眠1000ms</span>
                    <span class="type">Thread</span>.sleep(<span class="number">1000</span>);
            }
        } <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>ThreadB类似：</p>
<pre><code><span class="keyword">package</span> cn.wiz.roc.thread;

public <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Thread</span> {</span>
    public <span class="type">ThreadB</span>(<span class="type">String</span> name) {
        <span class="keyword">super</span>(name);
    }

    public synchronized void run() {
        <span class="keyword">try</span> {
            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {
                <span class="type">System</span>.out.println(<span class="keyword">this</span>.getName() + <span class="string">":"</span> + i);
                <span class="comment">// i能被4整除时，休眠100毫秒</span>
                <span class="keyword">if</span> (i % <span class="number">4</span> == <span class="number">0</span>)
                    <span class="type">Thread</span>.sleep(<span class="number">1500</span>);
            }
        } <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>SleepTest.java    </p>
<pre><code><span class="keyword">package</span> cn.wiz.roc.thread;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepTest</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        ThreadA t1 = <span class="keyword">new</span> ThreadA(<span class="string">"A"</span>);
        ThreadB t2 = <span class="keyword">new</span> ThreadB(<span class="string">"B"</span>);
        t1.start();
        t2.start();
    }
}
</code></pre><p>其中一段执行结果：</p>
<pre><code>...
<span class="label">A:</span><span class="number">16</span>
<span class="label">A:</span><span class="number">17</span>
<span class="label">A:</span><span class="number">18</span>
<span class="label">A:</span><span class="number">19</span>
<span class="label">A:</span><span class="number">20</span>
<span class="label">A:</span><span class="number">21</span>
<span class="label">B:</span><span class="number">17</span>
<span class="label">B:</span><span class="number">18</span>
<span class="label">B:</span><span class="number">19</span>
<span class="label">B:</span><span class="number">20</span>
...
</code></pre><blockquote>
<p>对于多线程环境，<code>start()</code>方法会通过底层的API执行重写的<code>run()</code>方法，使该方法获得竞争CPU计算的能力。在方法的执行过程中，原来的调用环境依次往下执行，不会等待<code>run()</code>方法执行结束。<br>run()的过程里，可以调用<code>Thread.sleep(1000);</code>使得线程休眠。当然，Thread还有其他几个方法，在此不再赘述。<br>–Roc</p>
</blockquote>
<hr>
<h2 id="Thread-sleep()和Thread-currentThread()-sleep()区别">Thread.sleep()和Thread.currentThread().sleep()区别</h2><blockquote>
<p>线程可以用继承<strong>Thread类</strong>或者实现<strong>Runnable接口</strong>来实现.</p>
<p>Thread.sleep()是Thread类的方法,只对当前线程起作用,睡眠一段时间.</p>
<p>如果线程是通过继承Thread实现的话这2个方法没有区别；</p>
<p>如果线程是通过实现Runnable接口来实现的,则不是Thread类,不能直接使用Thread.sleep()</p>
<p>必须使用Thread.currentThread()来得到当前线程的引用才可以调用sleep(),</p>
<p>所以要用Thread.currentThread().sleep()来睡眠…</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/photo.jpg" alt="Coder_Roc" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Coder_Roc</p>
        </div>
        <p class="site-description motion-element" itemprop="description">诚信，认真，专注，踏实</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">47</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">62</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/cshijiel" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/cshijiel" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/cshijiel" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp;  2014 - 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Coder_Roc</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"usee"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
