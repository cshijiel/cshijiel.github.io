<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="诚信，认真，专注，踏实" />



  <meta name="keywords" content="Java,互联网,NodeJS" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="诚信，认真，专注，踏实">
<meta property="og:type" content="website">
<meta property="og:title" content="Roc`s 随想录">
<meta property="og:url" content="http://coderroc.com/page/2/index.html">
<meta property="og:site_name" content="Roc`s 随想录">
<meta property="og:description" content="诚信，认真，专注，踏实">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Roc`s 随想录">
<meta name="twitter:description" content="诚信，认真，专注，踏实">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'hide'
  };
</script>

  <title> Roc`s 随想录 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Roc`s 随想录</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/21/知识记录/Resource-Autowired-Inject/" itemprop="url">
                spring下应用@Resource, @Autowired 和 @Inject注解进行依赖注入的差别
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-21T17:20:08+08:00" content="2015-04-21">
            2015-04-21
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/知识记录/" itemprop="url" rel="index">
                  <span itemprop="name">知识记录</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/21/知识记录/Resource-Autowired-Inject/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/21/知识记录/Resource-Autowired-Inject/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <h2 id="Overview">Overview</h2><p>When using Spring there’s the choice of 3 annotations for injecting resources with advantages and disadvantages :<br><code>@Autowired</code><br>The original, “proprietary” annotation from Spring. </p>
<ul>
<li>not standard, Spring proprietary </li>
</ul>
<ul>
<li>resolves by type </li>
<li>for optional dependencies<br><code>@Resource</code><br>The  <code>JSR-250</code> annotation </li>
<li>standard dependency injection </li>
</ul>
<ul>
<li>resolves by name, fallback by type </li>
<li>not for optional dependencies<br><code>@Inject</code><br>The  <code>JSR-330</code> annotation </li>
</ul>
<ul>
<li>resolves by type </li>
<li>standard dependency injection </li>
</ul>
<ul>
<li>not for optional dependencies </li>
</ul>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/04/21/知识记录/Resource-Autowired-Inject/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/21/知识记录/Java基础/IoC-and-DI/" itemprop="url">
                IoC and DI
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-21T10:10:32+08:00" content="2015-04-21">
            2015-04-21
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Java基础/" itemprop="url" rel="index">
                  <span itemprop="name">Java基础</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/21/知识记录/Java基础/IoC-and-DI/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/21/知识记录/Java基础/IoC-and-DI/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <p>IOC：Inversion of Control 控制反转<br>DI:Dependency Injection 依赖注入</p>
<p>控制反转，从字面意思来看，就是控制权又被动变主动，最后又变回被动。</p>
<p>举个例子：<br>你的主管要求你做一件事情，这个时候就存在这么几个过程，</p>
<p>主管命令你做事情（这个时候主动权在主管，你是被动的）</p>
<p>你接到命令做事情（这个时候主题是你，你是主动的，控制权在你手里）</p>
<p>你完成事情（这个时候主题依然是你，控制权在你手里）</p>
<p>报告主管做完事情（主动权又叫交到主管手里了）</p>
<p>上面的整个过程就完成了一次IOC，从上面可以看出，IOC的基本思想是控制权的转换过程。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/04/21/知识记录/Java基础/IoC-and-DI/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/20/知识记录/Java基础/handler-picture/" itemprop="url">
                图片裁剪整理
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-20T23:09:09+08:00" content="2015-04-20">
            2015-04-20
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Java基础/" itemprop="url" rel="index">
                  <span itemprop="name">Java基础</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/20/知识记录/Java基础/handler-picture/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/20/知识记录/Java基础/handler-picture/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <p>图片裁剪，核心思想是指定<strong>起始点坐标</strong>和相对于起始点坐标的<strong>偏移向量</strong>，这样就可以精确的指定被裁减图片中的一个矩形区域。</p>
<p>核心代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"D:/wiz/1.jpg"</span>;</span><br><span class="line">String subpath = <span class="string">"D:/wiz/2.jpg"</span>;</span><br><span class="line"></span><br><span class="line">ImageInputStream iis = ImageIO.createImageInputStream(<span class="keyword">new</span> FileInputStream(name));</span><br><span class="line">Iterator&lt;ImageReader&gt; it = ImageIO.getImageReadersByFormatName(<span class="string">"jpg"</span>);</span><br><span class="line">ImageReader reader = it.next();</span><br><span class="line">reader.setInput(iis, <span class="keyword">true</span>);</span><br><span class="line">ImageReadParam param = reader.getDefaultReadParam();</span><br><span class="line">Rectangle rect = <span class="keyword">new</span> Rectangle(<span class="number">100</span>, <span class="number">200</span>, <span class="number">320</span>, <span class="number">525</span>);</span><br><span class="line">param.setSourceRegion(rect);</span><br><span class="line">BufferedImage bi = reader.read(<span class="number">0</span>, param);</span><br><span class="line">ImageIO.write(bi, <span class="string">"jpg"</span>, <span class="keyword">new</span> File(subpath));</span><br></pre></td></tr></table></figure></p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/04/20/知识记录/Java基础/handler-picture/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/15/知识记录/Linux基础/shell-echo-style/" itemprop="url">
                shell中echo显示风格
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-15T11:16:19+08:00" content="2015-04-15">
            2015-04-15
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Linux基础/" itemprop="url" rel="index">
                  <span itemprop="name">Linux基础</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/15/知识记录/Linux基础/shell-echo-style/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/15/知识记录/Linux基础/shell-echo-style/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <p>自己封装的一个小函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echox()&#123;&#10;        if [ $# = 1 ];&#10;        then&#10;&#10;&#60;!-- more --&#62;&#10;&#10;&#10;                echo -e &#34;\033[32m$1\033[0m&#34;&#10;        else&#10;                if [ $1 = &#34;r&#34; ]||[ $1 = &#34;red&#34; ];&#10;                then&#10;                        echo -e &#34;\033[31m$2\033[0m&#34;&#10;                elif [ $1 = &#34;g&#34; ]||[ $1 = &#34;green&#34; ]&#10;                then&#10;                        echo -e &#34;\033[32m$2\033[0m&#34;&#10;                elif [ $1 = &#34;y&#34; ]||[ $1 = &#34;yellow&#34; ]&#10;                then&#10;                        echo -e &#34;\033[33m$2\033[0m&#34;&#10;                elif [ $1 = &#34;g&#34; ]||[ $1 = &#34;green&#34; ]&#10;                then&#10;                        echo -e &#34;\033[34m$2\033[0m&#34;&#10;                else&#10;                        echo -e &#34;\033[35m$2\033[0m&#34;&#10;                fi&#10;        fi&#10;&#125;</span><br></pre></td></tr></table></figure>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/04/15/知识记录/Linux基础/shell-echo-style/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/15/知识记录/springmvc-url/" itemprop="url">
                SpringMVC URL传参方式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-15T11:04:43+08:00" content="2015-04-15">
            2015-04-15
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/知识记录/" itemprop="url" rel="index">
                  <span itemprop="name">知识记录</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/15/知识记录/springmvc-url/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/15/知识记录/springmvc-url/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><ol>
<li><p>ModalAndView</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@RequestMapping</span>(<span class="string">"/helloWorld"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mav.setViewName(<span class="string">"helloWorld"</span>);<span class="comment">//viewName 视图名称</span></span><br><span class="line">        mav.addObject(<span class="string">"message"</span>, <span class="string">"Hello World!"</span>);<span class="comment">// 往视图传递对象</span></span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Class级别这是<code>@RequestMapping</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Controller&#10;@RequestMapping(&#34;/appointments&#34;)&#10;public class AppointmentsController &#123;&#10;&#10;    private final AppointmentBook appointmentBook;&#10;    &#10;    @Autowired&#10;    public AppointmentsController(AppointmentBook appointmentBook) &#123;&#10;        this.appointmentBook = appointmentBook;&#10;    &#125;&#10;&#10;    @RequestMapping(method = RequestMethod.GET)&#10;    public Map&#60;String, Appointment&#62; get() &#123;&#10;        return appointmentBook.getAppointmentsForToday();&#10;    &#125;&#10;&#10;    @RequestMapping(value=&#34;/&#123;day&#125;&#34;, method = RequestMethod.GET)&#10;    public Map&#60;String, Appointment&#62; getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE) Date day, Model model) &#123;&#10;        return appointmentBook.getAppointmentsForDay(day);&#10;    &#125;&#10;&#10;    @RequestMapping(value=&#34;/new&#34;, method = RequestMethod.GET)&#10;    public AppointmentForm getNewForm() &#123;&#10;        return new AppointmentForm();&#10;    &#125;&#10;&#10;    @RequestMapping(method = RequestMethod.POST)&#10;    public String add(@Valid AppointmentForm appointment, BindingResult result) &#123;&#10;        if (result.hasErrors()) &#123;&#10;            return &#34;appointments/new&#34;;&#10;        &#125;&#10;        appointmentBook.addAppointment(appointment);&#10;        return &#34;redirect:/appointments&#34;;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@PathVirable</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value=&#34;/owners/&#123;ownerId&#125;&#34;, method=RequestMethod.GET)&#10;public String findOwner(@PathVariable String ownerId, Model model) &#123;&#10;  Owner owner = ownerService.findOwner(ownerId);  &#10;  model.addAttribute(&#34;owner&#34;, owner);  &#10;  return &#34;displayOwner&#34;; &#10;&#125;&#10;&#10;&#10;@RequestMapping(value=&#34;/owners/&#123;ownerId&#125;&#34;, method=RequestMethod.GET)&#10;public String findOwner(@PathVariable(&#34;ownerId&#34;) String ownerId, Model model) &#123;&#10;  // implementation omitted&#10;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>待完善…</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/10/知识记录/MyBatis/" itemprop="url">
                MyBatis
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-10T16:01:32+08:00" content="2015-04-10">
            2015-04-10
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/10/知识记录/MyBatis/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/10/知识记录/MyBatis/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/images/mybatis-logo.png" alt="mybatis-logo"></p>
<h4 id="首先使用MySql（MariaDB）测试">首先使用MySql（MariaDB）测试</h4><p>√测试成功</p>
<h2 id="什么是_MyBatis_？">什么是 MyBatis ？</h2><p>MyBatis 是支持<strong>定制化 SQL</strong>、<strong>存储过程</strong>以及<strong>高级映射</strong>的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手工设置参数以及抽取结果集。MyBatis 使用简单的 <strong>XML</strong> 或<strong>注解</strong>来配置和映射基本体，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>
<h2 id="入门">入门</h2><p>###安装<br>想要使用 MyBatis 只需将 mybatis-x.x.x.jar 文件置于 classpath 中。</p>
<p>如果使用 Maven 构建项目，则需将下面的 dependency 置于 pom.xml 中：</p>
<pre><code><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</code></pre><h2 id="探究已映射的_SQL_语句">探究已映射的 SQL 语句</h2><p>这里给出一个基于 XML 映射语句的示例，它应该可以满足上述示例中 SqlSession 的调用。</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="doctype">&lt;!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span>
<span class="tag">&lt;<span class="title">mapper</span> <span class="attribute">namespace</span>=<span class="value">"org.mybatis.example.BlogMapper"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">select</span> <span class="attribute">id</span>=<span class="value">"selectBlog"</span> <span class="attribute">resultType</span>=<span class="value">"Blog"</span>&gt;</span>
    select * from Blog where id = #{id}
  <span class="tag">&lt;/<span class="title">select</span>&gt;</span>
<span class="tag">&lt;/<span class="title">mapper</span>&gt;</span>
</code></pre><p>插一句：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSession</span></span>
</code></pre><p>这个接口设计的太好了，如下</p>
<pre><code>&lt;T&gt; T selectOne(<span class="built_in">String</span> statement, <span class="built_in">Object</span> parameter);
</code></pre><p>根据接收类型选择返回类型。</p>
<p>好，回来，看看里边的其中一条语句：</p>
<pre><code>&lt;mapper <span class="keyword">namespace</span>=<span class="string">"org.mybatis.example.BlogMapper"</span>&gt;
  &lt;<span class="keyword">select</span> id=<span class="string">"selectBlog"</span> resultType=<span class="string">"Blog"</span>&gt;
    <span class="keyword">select</span> * <span class="keyword">from</span> Blog <span class="keyword">where</span> id = <span class="preprocessor">#{id}</span>
  &lt;/<span class="keyword">select</span>&gt;
&lt;/mapper&gt;
</code></pre><p>这个剩余部分具有很好的自解释性。在命名空间“com.mybatis.example.BlogMapper”中定义了一个名为“<code>selectBlog</code>”的映射语句，这样它就允许你使用指定的完全限定名“org.mybatis.example.BlogMapper.selectBlog”来调用映射语句，就像上面的例子中做的那样：</p>
<pre><code><span class="keyword">Blog </span><span class="keyword">blog </span>= (<span class="keyword">Blog) </span>session.<span class="keyword">selectOne("org.mybatis.example.BlogMapper.selectBlog", </span><span class="number">101</span>)<span class="comment">;</span>
</code></pre><p><strong>另一种办法</strong></p>
<p>你可能注意到这和使用完全限定名调用 Java 对象的方法是相似的，之所以这样做是有原因的。这个命名可以直接映射到在命名空间中同名的 Mapper 类，并在已映射的 select 语句中的名字、参数和返回类型匹配成方法。这样你就可以向上面那样很容易地调用这个对应 Mapper 接口的方法。不过让我们再看一遍下面的例子：</p>
<pre><code><span class="keyword">BlogMapper </span>mapper = session.getMapper(<span class="keyword">BlogMapper.class);
</span><span class="keyword">Blog </span><span class="keyword">blog </span>= mapper.<span class="keyword">selectBlog(101);</span>
</code></pre><p>第二种方法有很多优势，首先它不是基于字符串常量的，就会更安全；其次，如果你的 IDE 有<strong>代码补全</strong>功能，那么你可以在有了已映射的 SQL 语句之后利用这个功能。</p>
<p>对于像 BlogMapper 这样的映射器类（Mapper class）来说，还有另一招来处理映射。它们的映射的语句可以不需要用 XML 来做，取而代之的可以是 Java 注解。比如，上面的 XML 示例可被替换如下：</p>
<pre><code><span class="keyword">package</span> org.mybatis.example;
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> </span>{
  <span class="annotation">@Select</span>(<span class="string">"SELECT * FROM blog WHERE id = #{id}"</span>)
  <span class="function">Blog <span class="title">selectBlog</span><span class="params">(<span class="keyword">int</span> id)</span></span>;
}
</code></pre><p><strong>对于简单语句来说，注解使代码显得更加简洁，然而 Java 注解对于稍微复杂的语句就会力不从心并且会显得更加混乱。</strong>因此，如果你需要做很复杂的事情，那么最好使用 XML 来映射语句。</p>
<h2 id="范围（Scope）和生命周期">范围（Scope）和生命周期</h2><p><strong><code>提示</code> 对象的生命周期和依赖注入框架</strong></p>
<p>依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器（mapper）并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。如果对如何通过依赖注入框架来使用 MyBatis 感兴趣可以研究一下<code>MyBatis-Spring</code>或 MyBatis-Guice 两个子项目。</p>
<p>###SqlSessionFactoryBuilder</p>
<p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳范围是方法范围（也就是本地方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。</p>
<p>###SqlSessionFactory</p>
<p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（<strong>bad smell</strong>）”。因此 SqlSessionFactory 的最佳范围是应用范围。有很多方法可以做到，最简单的就是使用<strong>单例模式</strong>或者静态单例模式。</p>
<p>###SqlSession</p>
<p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的范围是请求或方法范围。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例域也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理范围中，比如 Serlvet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的范围中。</p>
<blockquote>
<p><strong>换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession；返回一个响应，就关闭它。</strong></p>
</blockquote>
<p>这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。下面的示例就是一个确保 SqlSession 关闭的标准模式：</p>
<pre><code>SqlSession session = sqlSessionFactory.openSession();
<span class="keyword">try</span> {
  <span class="comment">// do work</span>
} <span class="keyword">finally</span> {
  session.close();
}
</code></pre><p>你应该在你的所有的代码中<strong>一致性地使用这种模式</strong>来保证所有数据库资源都能被正确地关闭。</p>
<h2 id="问题">问题</h2><ul>
<li>MyBatis运行流程</li>
<li>MyBatis缓存机制</li>
</ul>
<h2 id="参考资料">参考资料</h2><p><a href="http://sishuok.com/forum/blogPost/list/3899.html" target="_blank" rel="external">Mybatis原理分析一 从JDBC到Mybaits </a><a href="http://sishuok.com/forum/blogPost/list/3899.html" target="_blank" rel="external">http://sishuok.com/forum/blogPost/list/3899.html</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/09/思维改变生活/how-to-grow-up-quickly/" itemprop="url">
                怎样，才能更快的成长？
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-09T22:47:33+08:00" content="2015-04-09">
            2015-04-09
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/思维改变生活/" itemprop="url" rel="index">
                  <span itemprop="name">思维改变生活</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/09/思维改变生活/how-to-grow-up-quickly/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/09/思维改变生活/how-to-grow-up-quickly/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="精力有限">精力有限</h2><p>首先，<strong>精力有限，所以要针对性的努力</strong>。精力在很大一部分就体现在时间上，我们每个人每天就24小时（最近的一则新闻真的很吓人），当然不可能24小时都在工作，除去必须花费的“日常开销”，洗漱、洗衣、交通、吃饭、睡觉还可能会走神等等之外，剩余时间其实不多了。对，那些必须花费的时间也可以称作“暗时间”，可以参考刘未鹏的博文<a href="http://mindhacks.cn/2009/12/20/dark-time/" target="_blank" rel="external">暗时间</a>。</p>
<h2 id="效率需要提高">效率需要提高</h2><p>有的时候，我们可能会花掉很长的时间，但是可能收获却不怎么大。那是为什么呢？<br>我感觉这个公式比较有说服力</p>
<pre><code><span class="attribute">W</span>=<span class="string">PT</span>
</code></pre><p>换言之，也就是</p>
<pre><code><span class="attribute">成果</span>=<span class="string">效率*时间</span>
</code></pre><p><strong>时间和效率</strong>都要到位才会产生最大的能量。</p>
<h2 id="选择">选择</h2><p>很多人说，选择大于努力。在一定程度上是这样的，但是不要太注重选择，选择的心思花的多了，就会容易投机，投机无论取得多大的成就，我总是感觉不靠谱。</p>
<p>适当选择，把心思主要花在正事上。</p>
<h2 id="合理的计划">合理的计划</h2><p>制定合理的计划，修正计划等。</p>
<p><strong>可以专门的写个网页来记录</strong>，督促自己来完成。</p>
<h2 id="素养、习惯和精神">素养、习惯和精神</h2><p>在面试的时候，有很多面试官喜欢问，看没有看过源代码，这个是怎么实现的等比较本质的东西。<br>对，本质永不落伍，本质才是最重要的，反映某些编程思想的所在。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/知识记录/深入学习微框架：Spring Boot/" itemprop="url">
                深入学习微框架：Spring Boot
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/知识记录/" itemprop="url" rel="index">
                  <span itemprop="name">知识记录</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/知识记录/深入学习微框架：Spring Boot/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/知识记录/深入学习微框架：Spring Boot/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>转自：<a href="http://www.infoq.com/cn/articles/microframeworks1-spring-boot" target="_blank" rel="external">http://www.infoq.com/cn/articles/microframeworks1-spring-boot</a><br>参考视频：<a href="http://www.tudou.com/programs/view/gWhLS4wIvgU/" target="_blank" rel="external">http://www.tudou.com/programs/view/gWhLS4wIvgU/</a><br><a href="http://www.cnblogs.com/suncj/p/4065589.html" target="_blank" rel="external">http://www.cnblogs.com/suncj/p/4065589.html</a><br><a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-creating-and-dropping-jpa-databases" target="_blank" rel="external">http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-creating-and-dropping-jpa-databases</a><br><a href="http://www.infoq.com/cn/articles/microframeworks1-spring-boot" target="_blank" rel="external">http://www.infoq.com/cn/articles/microframeworks1-spring-boot</a></p>
<blockquote>
<p>@Query()使用HQL语句。Hibernate查询方式。</p>
</blockquote>
<p>SpringBoot的Pom文件简介</p>
<blockquote>
<p>HSQLDB是一个开放源代码的JAVA数据库</p>
</blockquote>
<p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而<strong>使开发人员不再需要定义样板化的配置</strong>。通过这种方式，Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。</p>
<p>多年以来，Spring IO平台饱受非议的一点就是<strong>大量的XML配置以及复杂的依赖管理</strong>。在去年的SpringOne 2GX会议上，Pivotal的CTO Adrian Colyer回应了这些批评，并且特别提到该平台将来的目标之一就是实现免XML配置的开发体验。Boot所实现的功能超出了这个任务的描述，开发人员不仅不再需要编写XML，而且在一些场景中甚至不需要编写繁琐的import语句。在对外公开的beta版本刚刚发布之时，<strong>Boot描述了如何使用该框架在140个字符内实现可运行的web应用，从而获得了极大的关注度，该样例发表在tweet上</strong>。</p>
<p>然而，Spring Boot并不是要成为Spring IO平台里面众多“Foundation”层项目的替代者。Spring Boot的目标不在于为已解决的问题域提供新的解决方案，而是<strong>为平台带来另一种开发体验</strong>，从而简化对这些已有技术的使用。对于已经熟悉Spring生态系统的开发人员来说，Boot是一个很理想的选择，不过对于采用Spring技术的新人来说，Boot提供一种更简洁的方式来使用这些技术。</p>
<p>在追求开发体验的提升方面，Spring Boot，甚至可以说整个Spring生态系统都使用到了Groovy编程语言。Boot所提供的众多便捷功能，都是借助于Groovy强大的MetaObject协议、可插拔的AST转换过程以及内置的依赖解决方案引擎所实现的。在其核心的编译模型之中，Boot使用Groovy来构建工程文件，所以它可以使用通用的导入和样板方法（如类的main方法）对类所生成的字节码进行装饰（decorate）。这样使用Boot编写的应用就能保持非常简洁，却依然可以提供众多的功能。</p>
<h3 id="安装Boot">安装Boot</h3><p>从最根本上来讲，<strong>Spring Boot就是一些库的集合</strong>，它能够被任意项目的构建系统所使用。简便起见，该框架也提供了命令行界面，它可以用来运行和测试Boot应用。框架的发布版本，包括集成的CLI（命令行界面），可以在Spring仓库中手动下载和安装。一种更为简便的方式是使用<strong>Groovy</strong>环境管理器（Groovy enVironment Manager，GVM），它会处理Boot版本的安装和管理。Boot及其CLI可以通过GVM的命令行gvm install springboot进行安装。在OS X上安装Boot可以使用Homebrew包管理器。为了完成安装，首先要使用brew tap pivotal/tap切换到Pivotal仓库中，然后执行brew install springboot命令。</p>
<p>要进行打包和分发的工程会依赖于像Maven或Gradle这样的构建系统。为了简化依赖图，Boot的功能是模块化的，通过导入Boot所谓的“starter”模块，可以将许多的依赖添加到工程之中。为了更容易地管理依赖版本和使用默认配置，框架提供了一个parent POM，工程可以继承它。Spring Boot工程的样例POM文件定义如程序清单1所示。</p>
<p>程序清单1</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">project</span> <span class="attribute">xmlns</span>=<span class="value">"http://maven.apache.org/POM/4.0.0"</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="title">modelVersion</span>&gt;</span>

    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>myproject<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="title">version</span>&gt;</span>

    <span class="comment">&lt;!-- Inherit defaults from Spring Boot --&gt;</span>
    <span class="tag">&lt;<span class="title">parent</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.0.RC1<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">parent</span>&gt;</span>

    <span class="comment">&lt;!-- Add typical dependencies for a web application --&gt;</span>
    <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span>
        <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span>

    <span class="tag">&lt;<span class="title">repositories</span>&gt;</span>
        <span class="tag">&lt;<span class="title">repository</span>&gt;</span>
            <span class="tag">&lt;<span class="title">id</span>&gt;</span>spring-snapshots<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
            <span class="tag">&lt;<span class="title">url</span>&gt;</span>http://repo.spring.io/libs-snapshot<span class="tag">&lt;/<span class="title">url</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">repository</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">repositories</span>&gt;</span>

    <span class="tag">&lt;<span class="title">pluginRepositories</span>&gt;</span>
        <span class="tag">&lt;<span class="title">pluginRepository</span>&gt;</span>
            <span class="tag">&lt;<span class="title">id</span>&gt;</span>spring-snapshots<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
            <span class="tag">&lt;<span class="title">url</span>&gt;</span>http://repo.spring.io/libs-snapshot<span class="tag">&lt;/<span class="title">url</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">pluginRepository</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">pluginRepositories</span>&gt;</span>

    <span class="tag">&lt;<span class="title">build</span>&gt;</span>
        <span class="tag">&lt;<span class="title">plugins</span>&gt;</span>
            <span class="tag">&lt;<span class="title">plugin</span>&gt;</span>
                <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
                <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">plugins</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">build</span>&gt;</span>
<span class="tag">&lt;/<span class="title">project</span>&gt;</span>
</code></pre><p>为了实现更为简单的构建配置，开发人员可以使用Gradle构建系统中简洁的Groovy DSL，如程序清单1.1所示。</p>
<p>程序清单1.1</p>
<pre><code><span class="keyword">buildscript</span> {
  <span class="keyword">repositories</span> {
    maven { url <span class="string">"http://repo.spring.io/libs-snapshot"</span> }
    mavenCentral()
  }
  <span class="keyword">dependencies</span> {
    <span class="keyword">classpath</span>(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:1.0.0.RC1"</span>)
  }
}

apply plugin: <span class="string">'java'</span>
apply plugin: <span class="string">'spring-boot'</span>
<span class="keyword">repositories</span> {
  mavenCentral()
  maven { url <span class="string">"http://repo.spring.io/libs-snapshot"</span>  }
}

<span class="keyword">dependencies</span> {
  <span class="keyword">compile</span> <span class="string">'org.springframework.boot:spring-boot-starter-actuator:1.0.0.RC1'</span>
}
</code></pre><p>为了快速地搭建和运行Boot工程，Pivotal提供了称之为“Spring Initializr” 的web界面，用于下载预先定义好的Maven或Gradle构建配置。我们也可以使用Lazybones模板实现快速起步，在执行lazybones create spring-boot-actuator my-app命令后，它会为Boot应用创建必要的工程结构以及gradle构建文件。</p>
<h3 id="开发Spring_Boot应用">开发Spring Boot应用</h3><p>Spring Boot在刚刚公开宣布之后就将一个样例发布到了Twitter上，它目前成为了最流行的一个应用样例。它的全部描述如程序清单1.2所示，一个非常简单的Groovy文件可以生成功能强大的以Spring为后端的web应用。</p>
<p>程序清单1.2</p>
<pre><code><span class="annotation">@RestController</span>
<span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{
  <span class="annotation">@RequestMapping</span>(<span class="string">"/"</span>)
  <span class="built_in">String</span> home() {
    <span class="string">"hello"</span>
  }
}
</code></pre><p>这个应用可以通过spring run App.groovy命令在Spring Boot CLI中运行。Boot会分析文件并根据各种“编译器自动配置（compiler auto-configuration）”标示符来确定其意图是生成Web应用。然后，它会在一个嵌入式的Tomcat中启动Spring应用上下文，并且使用默认的8080端口。打开浏览器并导航到给定的URL，随后将会加载一个页面并展现简单的文本响应：“hello”。提供默认应用上下文以及嵌入式容器的这些过程，能够让开发人员更加关注于开发应用以及业务逻辑，从而不用再关心繁琐的样板式配置。</p>
<p>Boot能够自动确定类所需的功能，这一点使其成为了强大的快速应用开发工具。当应用在Boot CLI中执行时，它们在使用内部的Groovy编译器进行构建，这个编译器可以在字节码生成的时候以编码的方式探查并修改类。通过这种方式，使用CLI的开发人员不仅可以省去定义默认配置，在一定程度上甚至可以不用定义特定的导入语句，它们可以在编译的过程中识别出来并自动进行添加。除此之外，当应用在CLI中运行时，Groovy内置的依赖管理器，“Grape”，将会解析编译期和运行时的类路径依赖，与Boot编译器的自动配置机制类似。这种方式不仅使得框架更加对用户友好，而且能够让不同版本的Spring Boot与特定版本的来自于Spring IO平台的库相匹配，这样一来开发人员就不用关心如何管理复杂的依赖图和版本结构了。另外，它还有助于快速原型的开发并生成概念原型的工程代码。</p>
<p><strong>对于不是使用CLI构建的工程，Boot提供了许多的“starter”模块，它们定义了一组依赖，这些依赖能够添加到构建系统之中，从而解析框架及其父平台所需的特定类库。</strong>例如，spring-boot-starter-actuator依赖会引入一组基本的Spring项目，从而实现应用的快速配置和即时可用。关于这种依赖，值得强调的一点就是当开发Web应用，尤其是RESTful Web服务的时候，如果包含了spring-boot-starter-web依赖，它就会为你提供启动嵌入式Tomcat容器的自动化配置，并且提供对微服务应用有价值的端点信息，如服务器信息、应用指标（metrics）以及环境详情。除此之外，如果引入spring-boot-starter-security模块的话，actuator会自动配置Spring Security，从而为应用提供基本的认证以及其他高级的安全特性。它还会为应用结构引入一个内部的审计框架，这个框架可以用来生成报告或其他的用途，比如开发认证失败的锁定策略。</p>
<p>为了阐述在Java Maven工程中，如何快速地使Spring Web工程准备就绪，考虑一下程序清单1.3中的应用程序代码。</p>
<p>程序清单1.3</p>
<pre><code><span class="keyword">package</span> com.infoq.springboot;

<span class="keyword">import</span> org.springframework.boot.SpringApplication;
<span class="keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;
<span class="keyword">import</span> org.springframework.web.bind.annotation.*;

<span class="annotation">@RestController</span>
<span class="annotation">@EnableAutoConfiguration</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>{

  <span class="annotation">@RequestMapping</span>(<span class="string">"/"</span>)
  <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="string">"Hello"</span>;
  }

  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
    SpringApplication.run(Application.class, args);
  }
}
</code></pre><p>在Application类上的@EnableAutoConfiguration注解会告知Boot要采用一种特定的方式来对应用进行配置。这种方法会将其他样板式的配置均假设为框架默认的约定，因此能够聚焦于如何尽快地使应用准备就绪以便运行起来。Application类是可运行的，因此，当我们以Java Application的方式运行这个类时，就能启动该应用及其嵌入式的容器，这样也能实现即时地开发。</p>
<p>为了发布版本而构建工程时，Boot的Maven和Gradle插件可以嵌入（hook）到这些构建系统的打包过程中，以生成可执行的“胖jar包（fat jar）”，这种jar包含了工程的所有依赖并且能够以可运行jar的方式执行。使用Maven打包Boot应用只需运行mvn package命令，与之类似，使用Gradle时，执行gradle build命令将会在构建的目标地址下生成可运行的jar。</p>
<p>开发微服务</p>
<p>Boot对Spring应用的开发进行了简化，提供了模块化方式导入依赖的能力，强调了开发RESTful Web服务的功能并提供了生成可运行jar的能力，这一切都清晰地表明在开发可部署的微服务方面Boot框架是一个强大的工具。正如前面的例子所示，借助于Boot，让一个RESTful Web工程运行起来是一件很容易的事情；不过，为了了解Boot所有潜在的功能，我们会阐述在开发完整功能的微服务时，会遇到的所有繁琐的事情。在企业级基础<strong>设施领域，微服务是一种越来越流行的应用架构，因为它能够实现快速开发、更小的代码库、企业级集成以及模块化部署。</strong>有众多的框架致力于该领域的开发，该章节将会讨论使用Boot如何简化这一过程。</p>
<h3 id="数据访问">数据访问</h3><p>我们可以基于各种目的来构建微服务，但有一点是肯定的，<strong>那就是大多数都需要读取和写入数据库的能力</strong>。Spring Boot使数据库集成变成了一项非常简单的任务，<strong>因为它具有自动配置Spring Data以访问数据库的能力</strong>。只需在你的工程中将<code>spring-boot-starter-data-jpa</code>包含进来，Boot的自动配置引擎就能探测到你的工程需要数据访问功能，并且会在Spring应用上下文中创建必要的Bean，这样你就可以使用Repository和服务了。为了更具体地阐述这一点，请参见程序清单1.4中的Gradle构建文件，它列出了一个基于Groovy的微服务web应用的构建结构，该应用使用了Spring Data对JPA的支持来实现数据访问。</p>
<p>程序清单1.4</p>
<pre><code><span class="keyword">buildscript</span> {
  <span class="keyword">repositories</span> {
    maven { url <span class="string">"http://repo.spring.io/libs-snapshot"</span> }
    mavenCentral()
  }
  <span class="keyword">dependencies</span> {
    <span class="keyword">classpath</span>(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:1.0.0.RC1"</span>)
  }
}

apply plugin: <span class="string">'groovy'</span>
apply plugin: <span class="string">'spring-boot'</span>

<span class="keyword">repositories</span> {
  mavenCentral()
  maven { url <span class="string">"http://repo.spring.io/libs-snapshot"</span>  }
}

ext {
  springBootVersion = <span class="string">"1.0.0.RC1"</span>
}

<span class="keyword">dependencies</span> {
  <span class="keyword">compile</span> <span class="string">'org.codehaus.groovy:groovy-all:2.2.1'</span>
  <span class="keyword">compile</span> <span class="string">"org.springframework.boot:spring-boot-starter-web:$springBootVersion"</span>
  <span class="keyword">compile</span> <span class="string">"org.springframework.boot:spring-boot-starter-data-jpa:$springBootVersion"</span>
  <span class="keyword">compile</span> <span class="string">"org.springframework.boot:spring-boot-starter-actuator:$springBootVersion"</span>
}
</code></pre><p>在这个配置中，Boot的actuator模块提供了对hsqldb的依赖，这会搭建所有必要的依赖——包括模式的创建——因此Spring Data可以使用这个内存数据库作为数据源。这种简便的方式能够让开发人员免于在开发期创建和管理复杂的XML配置，进而能够快速地开发数据库驱动的微服务。如果在classpath中有H2或Derby数据库的话，这种自动化配置也会生效。Boot所提供的另一个便利之处就是能够快速简便地使用相关数据启动应用的数据库模式。这在开发期是非常有用的，此时数据库可能是在内存中或者是不稳定的，开发人员需要保证的是在应用启动的时候能够访问到这些特定的数据。为了阐述这一点，考虑一下程序清单1.5中的示例JPA实体，它代表了微服务所提供的“User”数据结构。</p>
<p>程序清单1.5</p>
<pre><code><span class="variable">@Entity</span>
class User {
  <span class="variable">@Id</span>
  <span class="variable">@GeneratedValue</span>
  Long id

  String username
  String firstName
  String lastName
  Date createdDate
  Date lastAccessed

  Boolean isActive = Boolean.TRUE
}
</code></pre><p>为了启用代表User对象的通用数据，我们只需创建一个名为schema.sql或data.sql的文件，并将其包含在classpath之中。这个文件会在模式创建完成之后执行，所以基于程序清单1.5所给出的实体，我们可以使用SQL语句启用一个用户账号，如程序清单1.6所示。</p>
<p>程序清单1.6</p>
<pre><code>insert into <span class="function"><span class="title">user</span><span class="params">(username, first_name, last_name, created_date)</span></span> values (<span class="string">'danveloper'</span>, <span class="string">'Dan'</span>, <span class="string">'Woods'</span>, <span class="function"><span class="title">now</span><span class="params">()</span></span>)
</code></pre><p>在启动的时候，我们所提供的SQL代码会执行，这样就能确保有一个测试账号可以使用。微服务此时已经具有了数据访问的起始点，程序清单1.7展现了如何按照Spring Data的开发模式创建Repository接口，该接口会作为User实体的数据访问对象（Data Access Object）。</p>
<p>程序清单1.7</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>{
}
</code></pre><p>CrudRepository提供了一些通用的接口方法来创建、查询、更新以及删除对象和对象集合。应用所需的其他特定功能可以按照Spring Data的Repository开发约定进行定义。一旦UserRepository接口创建成功，Boot的spring-data-jpa层会在工程中探测到它，并将其添加到Spring应用上下文之中，这样对于controller和sevice对象来说，它就成为可以进行自动注入的可选对象。这种自动化的配置只有在Boot应用要求按照这种方式初始化的时候才生效，这是通过存在@EnableAutoConfiguration注解来标识的。借助程序清单1.8中所实现的controller，微服务现在就可以定义RESTful端点了，服务的使用者可以获取到User的列表或单个User。</p>
<p>程序清单1.8</p>
<pre><code><span class="annotation">@RestController</span>
<span class="annotation">@EnableAutoConfiguration</span>
<span class="annotation">@RequestMapping</span>(<span class="string">"/user"</span>)
<span class="class"><span class="keyword">class</span> <span class="title">UserController</span> {</span>

  <span class="annotation">@Autowired</span>
  UserRepository repository

  <span class="annotation">@RequestMapping</span>(method=[RequestMethod.GET])
  <span class="keyword">def</span> get(Long id) {
    id ? repository.findOne(id) : repository.findAll()
  }

  <span class="keyword">public</span> <span class="keyword">static</span> <span class="typename">void</span> main(String[] args) {
    SpringApplication.run UserController, args
  }
}
</code></pre><p>在启动的时候，应用将会输出日志，<strong>表明<code>Hibernate</code>按照User实体的定义创建数据库结构</strong>，在应用初始化的最后，Boot还会从schema.sql文件中导入数据。</p>
<p>在开发微服务应用时，需要特别注意的一点是使用了@RequestMapping注解。这不是Boot特定的注解。不过，因为Boot安装了自己的端点以监控应用的性能、健康情况以及配置，所以需要确保应用的代码不要与这些内置的提供详情的路径解析相冲突。鉴于此，如果有从请求路径中解析属性的需求（在我们的场景中，也就是user的id属性），那么我们需要仔细考虑这个动态的属性解析会对微服务的其他行为产生什么影响。在本例中，只是简单地将controller映射到/user端点而不是根上下文，就能允许Boot的端点也可以进行访问。</p>
<p>微服务所提供的数据并不一定全部适合关系型结构，针对这一点Spring Boot也暴露了一些模块，从而让开发人员可以使用Spring Data的MongoDB和Redis项目，不过依然采取特定的方式来进行配置。Spring Data用来定义数据访问对象（Data Access Object）的高层框架，这样快速切换JPA与非JPA数据源会变得非常容易。参见程序清单1.9，它展现了一个重新定义的UserRepository接口，这个接口设计为使用MongoDB取代JPA。</p>
<p>程序清单1.9</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>{
}
</code></pre><p>MongoRepository接口也扩展了CrudRepository，因此微服务的Controller代码，也就是程序清单1.8所示并不需要修改。为了实现与MongoDB的集成，工程唯一要做的就是在应用的classpath中包含spring-boot-starter-data-mongodb。程序清单1.4所示的Gradle构建文件需要稍微调整一下依赖的部分，如程序清单1.10所示。</p>
<p>程序清单1.10</p>
<pre><code><span class="keyword">dependencies</span> {
  <span class="keyword">compile</span> <span class="string">'org.codehaus.groovy:groovy-all:2.2.1'</span>
  <span class="keyword">compile</span> <span class="string">"org.springframework.boot:spring-boot-starter-web:$springBootVersion"</span>
  <span class="keyword">compile</span> <span class="string">"org.springframework.boot:spring-boot-starter-data-mongodb:$springBootVersion"</span>
  <span class="keyword">compile</span> <span class="string">"org.springframework.boot:spring-boot-starter-actuator:$springBootVersion"</span>
}
</code></pre><p>MongoDB依赖都置于classpath之中以后，Boot将会自动配置Spring Data连接到localhost上的数据库，并且默认的数据库名为test。在这个库中，将会自动创建User集合（按照MongoDB的标准），微服务现在就能使用MongoDB作为后端了。对非JPA的数据存储来说，初始化数据比其他的方式更为简单，这主要是因为它不能针对MongoDB的文档存储和Redis的键值存储运行SQL文件。鉴于Spring Data会使用这些存储的持久化实例，这就意味着开发期创建的数据需要在重启后保留。为了持久化数据，我们需要修改微服务的controller，这样服务的使用者就能创建User实例了。我们也可以将微服务的UserController进行修改，使其符合通用的RESTful API结构，让controller以不同的方式处理不同的HTTP方法。程序清单1.11展现了为controller添加创建新User实例的功能。</p>
<p>程序清单1.11</p>
<pre><code>@<span class="type">RestController</span>
@<span class="type">RequestMapping</span>(<span class="string">"/user"</span>)
@<span class="type">EnableAutoConfiguration</span>
class <span class="type">UserController</span> {

  @<span class="type">Autowired</span>
  <span class="type">UserRepository</span> repository

  @<span class="type">RequestMapping</span>(<span class="keyword">method</span>=[<span class="type">RequestMethod</span>.<span class="type">GET</span>])
  def get(<span class="type">Long</span> id) {
    id ? repository.findOne(id) : repository.findAll()
  }

  @<span class="type">RequestMapping</span>(<span class="keyword">method</span>=[<span class="type">RequestMethod</span>.<span class="type">POST</span>])
  def create(@<span class="type">RequestBody</span> <span class="type">User</span> user) {
    repository.save user
    user
  }

  public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) {
    <span class="type">SpringApplication</span>.run <span class="type">UserController</span>, args
  }
}
</code></pre><p>当微服务的使用者往应用的端点上发送一个HTTP POST请求时，Spring将会把请求体转换为User实例。代码接下来会使用UserRepository将这个对象存储到MongoDB集合之中。使用curl创建User实例的样例如程序清单1.12所示。</p>
<p>程序清单1.12</p>
<pre><code>curl -v -H "Content-Type: application/json" -d "<span class="special">{</span> <span class="command">\"</span>username<span class="command">\"</span>: <span class="command">\"</span>danveloper<span class="command">\"</span>, <span class="command">\"</span>firstName<span class="command">\"</span>: <span class="command">\"</span>Dan<span class="command">\"</span>, <span class="command">\"</span>lastName<span class="command">\"</span>: <span class="command">\"</span>Woods<span class="command">\"</span>, <span class="command">\"</span>createdDate<span class="command">\"</span>: <span class="command">\"</span>2014-02-02T00:00:00<span class="command">\"</span> <span class="special">}</span>" http://localhost:8080/user
</code></pre><p>按照Boot针对Mongo数据源的特定配置，新的User实例默认会持久化到本地Mongo实例的test数据库的user集合之中。如果我们打开web浏览器并对微服务发起一个HTTP GET请求，我们就能看到所创建的user存在于返回的列表之中。</p>
<p>配置</p>
<p>我们可以很快地重写Spring Boot的默认配置。默认情况下，应用的配置可以使用Java属性文件来进行定义，这个文件名为application.properties并且位于应用的classpath根目录下。<strong>不过，一种更好的方式是使用 YAML配置，它提供了结构化以及嵌套的配置。</strong>在应用的运行时类路径之中包含snakeyaml之后，你的工程就可以在application.yml文件中直接定义配置了。为了详述这一点，考虑程序清单1.13的示例YAML配置，这里列出了应用的嵌入式HTTP服务器（默认是Tomcat，也可选择Jetty）的各种设置项。</p>
<p>程序清单1.13</p>
<pre><code><span class="preprocessor"># Server settings (ServerProperties)</span>
server:
  port: <span class="number">8080</span>
  address: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>
  sessionTimeout: <span class="number">30</span>
  contextPath: /

  <span class="preprocessor"># Tomcat specifics</span>
  tomcat:
    accessLogEnabled: <span class="literal">false</span>
    protocolHeader: x-forwarded-proto
    remoteIpHeader: x-forwarded-<span class="keyword">for</span>
    basedir:
    backgroundProcessorDelay: <span class="number">30</span> <span class="preprocessor"># secs</span>
</code></pre><p>允许重写Boot的自动化配置，这一点能够使你的应用从原型转化为真正的产品，Boot使用相同的<strong>application.yml</strong>文件进行配置，这样就会非常容易。自动化配置的指令被设计的尽可能简短，所以当使用actuator构建微服务时，会安装一个配置属性的端点，也就是/configprops，当确定哪些指令需要重写时可以进行参考。如果我们的微服务要使用持久化数据源，如MySQL，那么只需将MySQL的Java驱动添加到运行时classpath中，然后在application.yml中添加必要的配置指令即可，如程序清单1.14所示。</p>
<p>程序清单1.14</p>
<pre><code><span class="attribute">spring</span>:
  <span class="attribute">datasource</span>:
    <span class="attribute">driverClassName</span>: com.mysql.jdbc.Driver
    <span class="attribute">url</span>: <span class="attribute">jdbc</span>:<span class="attribute">mysql</span>:<span class="comment">//localhost:3306/proddb</span>
    <span class="attribute">username</span>: root
    password
</code></pre><p>在一些场景下你可能需要更为灵活的配置，Boot允许你通过Java的系统属性（System properties）重写很多它的默认配置。例如，如果你的应用需要在部署到产品化环境中使用不同的数据库用户，那么username配置指令可以通过标准的Java系统属性传入到应用之中，而这需要切换到命令行中执行-Dspring.datasource.username=user。关于这一点更为现实的场景是云部署环境，如Cloud Foundry或Heroku，这些平台需要应用启动特定的HTTP端口，这一点通过操作系统的环境变量可以实现。Boot能够从系统属性继承得到配置，这样你的应用就可以在命令行中使用-Dserver.port=$PORT来得到HTTP端口。在开发微服务时，这是一种相当有用的特性，因为它可以让微服务应用运行在各种环境配置之中。</p>
<h3 id="外部化配置">外部化配置</h3><p>微服务必须要支持的很重要的一点就是<strong>外部化配置</strong>。这种配置可以包含任何的内容，从占位符信息到数据库配置等等，在初始规划和构建应用原型时，这是必须要考虑的架构内容。在Spring IO平台中，已经存在各种导入配置的策略，但是应用能够以多种方式使用配置所造成的后果往往是产生冗长的编码性耦合。</p>
<p>Boot一个很棒的特性在于它能管理外部化的配置并将其转换为对象结构，这个对象可以在整个应用上下文中使用。创建一个简单老式的Java/Groovy对象（Plain Old Java/Groovy Object），并使用@ConfigurationProperties注解，那么这个对象就能使用Boot配置结构中预先定义的name名下的配置项。更具体一点来讲，考虑一下程序清单1.15中的POGO，它能够得到application.key下的配置指令。</p>
<p>程序清单1.15</p>
<pre><code><span class="annotation">@ConfigurationProperties</span>(name = <span class="string">"application"</span>)
<span class="class"><span class="keyword">class</span> <span class="title">ApplicationProperties</span> </span>{
  <span class="built_in">String</span> name
  <span class="built_in">String</span> version
}
</code></pre><p><strong>当ApplicationProperties对象在Spring上下文中创建完成之后，Boot将会识别出它是一个配置对象，并且会按照运行时classpath之中application.properties或application.yml文件中的配置指令填充它的属性。</strong>因此，如果我们在微服务的application.yml文件中添加application内容区的话，如程序清单1.16所示，那么我们就可以在应用的其他部分以编程的方式访问这些配置指令。</p>
<p>程序清单1.16</p>
<pre><code><span class="type">application</span>:
  <span class="property">name</span>: sb-ms-custdepl
  <span class="property">version</span>: <span class="number">0.1</span>-CUSTOMER
</code></pre><p><strong>这些配置指令可以有各种用途，要访问这些指令的唯一要求就是代表它们的POJO/POGO必须是Spring应用上下文的成员。</strong> Boot能够将一个controller作为Spring Java配置对象，这样就能很容易地管理配置bean与应用上下文的集成，如程序清单1.17所示。</p>
<p>程序清单1.17</p>
<pre><code><span class="annotation">@RestController</span>
<span class="annotation">@Configuration</span>
<span class="annotation">@RequestMapping</span>(<span class="string">"/appinfo"</span>)
<span class="annotation">@EnableAutoConfiguration</span>
<span class="class"><span class="keyword">class</span> <span class="title">AppInfoController</span> </span>{

  <span class="annotation">@Autowired</span>
  ApplicationProperties applicationProperties

  <span class="annotation">@RequestMapping</span>(method=[RequestMethod.GET])
  <span class="function">def <span class="title">get</span><span class="params">()</span> </span>{
    [
      name: applicationProperties.name,
      version: applicationProperties.version
    ]
  }

  <span class="annotation">@Bean</span>
  <span class="function">ApplicationProperties <span class="title">applicationProperties</span><span class="params">()</span> </span>{
    <span class="keyword">new</span> ApplicationProperties()
  }

  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
    SpringApplication.run UserController, args
  }
}
</code></pre><p>程序清单1.17中的样例代码可能有些牵强，不过，即便是在更为复杂的场景下，如何使用Boot来访问应用特定配置的原则是相同的。<strong>配置类也支持嵌套式的对象图</strong>，这样来自于配置中的深层数据就能更便利地进行访问，也有了更好的语义。例如，如果我们想要得到的配置指令是application.根下的那些metrics key，那么可以在ApplicationProperties POGO中添加一个嵌套对象来表示这些值，如程序清单1.18所示。</p>
<p>程序清单1.18</p>
<pre><code><span class="annotation">@ConfigurationProperties</span>(name = <span class="string">"application"</span>)
<span class="class"><span class="keyword">class</span> <span class="title">ApplicationProperties</span> </span>{
  <span class="built_in">String</span> name
  <span class="built_in">String</span> version

  <span class="keyword">final</span> Metrics metrics = <span class="keyword">new</span> Metrics()

  <span class="literal">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Metrics</span> </span>{
    <span class="built_in">String</span> dbExecutionTimeKey
  }
}
</code></pre><p>现在，我们的application.yml文件可以如程序清单1.19所示，它在application.代码块中包含了metrics配置。</p>
<p>程序清单1.19</p>
<pre><code><span class="type">application</span>:
  <span class="property">name</span>: sb-ms-custdepl
  <span class="property">version</span>: <span class="number">0.1</span>-CUSTOMER
  metrics:
    dbExecutionTimeKey: user.<span class="keyword">get</span>.db.<span class="property">time</span>
</code></pre><p>当我们需要访问application.metrics.dbExecutionTimeKey的值时，能够以编程的方式通过ApplicationProperties对象来进行访问。</p>
<p>为了在整个应用之中使用application.properties或application.yml文件中的这些配置指令，我们并不是必须要将其转换为对象图。Boot也为Spring应用上下文提供了PropertySourcesPlaceholderConfiguration，这样的话，来自于application.properties或application.yml文件的指令或者来自于Java系统的重写属性都可以作为Spring属性占位符来使用。Spring的这种机制能够让你以一种特定的语法来为属性定义占位符值，如果Spring发现了占位符配置的话，就会用这个配置来进行填充。<strong>作为示例，我们可以在controller中使用@Value注解来直接访问application.metrics.dbExecutionTimeKey，如程序清单1.20所示。</strong></p>
<p>程序清单1.20</p>
<pre><code>@<span class="type">RestController</span>
@<span class="type">RequestMapping</span>(<span class="string">"/user"</span>)
@<span class="type">EnableAutoConfiguration</span>
class <span class="type">UserController</span> {

  @<span class="type">Autowired</span>
  <span class="type">UserRepository</span> repository

  @<span class="type">Autowired</span>
  <span class="type">GaugeService</span> gaugeService

  @<span class="type">Value</span>('${application.metrics.dbExecutionTimeKey}')
  <span class="type">String</span> dbExecutionKey

  @<span class="type">RequestMapping</span>(<span class="keyword">method</span>=[<span class="type">RequestMethod</span>.<span class="type">GET</span>])
  def get(<span class="type">Long</span> id) {
    def start = new <span class="type">Date</span>().time
    def <span class="literal">result</span> = id ? repository.findOne(id) : repository.findAll()
    gaugeService.submit dbExecutionKey, new <span class="type">Date</span>().time - start
    <span class="literal">result</span>
  }

  public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) {
    <span class="type">SpringApplication</span>.run <span class="type">UserController</span>, args
  }
}
</code></pre><p><strong>关于应用指标的报告，后面会有更为详细的介绍，但现在重要的一点在于，理解@Value注解如何与Spring属性占位符一起使用，使Boot能够自动注入值，从而满足这个微服务的特定配置需求。</strong></p>
<h3 id="安全">安全</h3><p>在微服务的开发中，对于完备安全场景的需求会持续增长。为了满足这种需求，Boot引入了强大完整的Spring Security，并且提供了自动配置的功能，以快速简便地启用安全层。只需在应用的classpath中包含spring-boot-starter-security模块就能使Boot引入一些安全特性，如跨站脚本防护（cross-site scripting protection）并且会添加头信息以防止点击劫持（click-jacking）。除此之外，添加一条简单的配置指令就能启用基本认证来保护你的应用，如程序清单1.21所示。</p>
<p>程序清单1.21</p>
<pre><code><span class="attribute">security</span>:
  <span class="attribute">basic</span>:
    <span class="attribute">enabled</span>: true
</code></pre><p>Boot会为你提供一个默认的用户账号user和默认角色USER，并且会在应用启动的时候在控制台上输出随机生成的密码。就像Boot的其他功能那样，对于内置的user账号，我们可以很容易地指定不同的用户名和密码（分别为“secured”和“foo”），这需要通过明确定义的配置指令来实现，如程序清单1.22所示。</p>
<p>程序清单1.22</p>
<pre><code><span class="attribute">security</span>:
  <span class="attribute">basic</span>:
    <span class="attribute">enabled</span>: true
  <span class="attribute">user</span>:
    <span class="attribute">name</span>: secured
    <span class="attribute">password</span>: foo
</code></pre><p>对于简单的内部应用或开发原型来说，Boot内置的基础设施能够快速地在微服务中启用基本认证，这是非常有用的。随着需求的演化，你的应用毫无疑问会需要更细粒度的安全特性，如保护端点只能由特定的角色访问。从这个角度来看，我们可能希望具有USER角色的调用者只能读取数据（即GET请求），而对具有ADMIN角色的调用者可以读取和写入数据（即POST请求）。为了做到这一点，我们需要在工程的application.yml文件中禁用Boot的基本认证自动配置功能，并且定义我们自己的user和admin账号以及对应的角色。当你的需求超过Boot所提供的默认功能时，它通常很快就能实现，这可以作为佐证这一点的又一个例子。为了更具体地阐述这一点，考虑一下程序清单1.23中的代码。这个样例可以阐述如何发挥Spring Security所有潜在的功能以及更为复杂的认证策略，如基于JDBC后端、OpenID或<strong>单点登录（Single-Sign On）。</strong></p>
<p>程序清单1.23</p>
<pre><code><span class="annotation">@RestController</span>
<span class="annotation">@RequestMapping</span>(<span class="string">"/user"</span>)
<span class="annotation">@Configuration</span>
<span class="annotation">@EnableGlobalMethodSecurity</span>(securedEnabled = <span class="literal">true</span>)
<span class="annotation">@EnableAutoConfiguration</span>
<span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">WebSecurityConfigurerAdapter</span> {</span>

  <span class="annotation">@Autowired</span>
  <span class="type">UserRepository</span> repository

  <span class="annotation">@RequestMapping</span>(method = [<span class="type">GET</span>])
  <span class="annotation">@Secured</span>([<span class="symbol">'ROLE_USE</span>R'])
  <span class="function"><span class="keyword">def</span> <span class="title">get</span>(</span><span class="type">Long</span> id) {
    <span class="comment">//这段代码写得很好，学习了。高度抽象</span>
    id ? repository.findOne(id) : repository.findAll()
  }

  <span class="annotation">@RequestMapping</span>(method = [<span class="type">POST</span>])
  <span class="annotation">@Secured</span>([<span class="symbol">'ROLE_ADMI</span>N'])
  <span class="function"><span class="keyword">def</span> <span class="title">create</span>(</span><span class="annotation">@RequestBody</span> <span class="type">User</span> user) {
    repository.save user
    user
  }

  <span class="annotation">@Override</span>
  void configure(<span class="type">AuthenticationManagerBuilder</span> auth) {
    auth
    .inMemoryAuthentication()
    .withUser <span class="string">"user"</span> password <span class="string">"password"</span> roles <span class="string">"USER"</span> and() withUser <span class="string">"admin"</span> password <span class="string">"password"</span> roles <span class="string">"USER"</span>, <span class="string">"ADMIN"</span>
  }

  <span class="annotation">@Override</span>
  void configure(<span class="type">HttpSecurity</span> http) <span class="keyword">throws</span> <span class="type">Exception</span> {
    <span class="type">BasicAuthenticationEntryPoint</span> entryPoint = <span class="keyword">new</span> <span class="type">BasicAuthenticationEntryPoint</span>()
    entryPoint.realmName = <span class="string">"Spring Boot"</span>
    http.exceptionHandling().authenticationEntryPoint(entryPoint)
    http.requestMatchers().antMatchers(<span class="string">"/**"</span>).anyRequest()
    .and().httpBasic().and().anonymous().disable().csrf().disable()
  }

  public static void main(<span class="type">String</span>[] args) {
    <span class="type">SpringApplication</span>.run <span class="type">UserController</span>, args
  }
}
</code></pre><p>在程序清单1.23的样例之中，应用现在被明确地配置为要基于user和admin用户账号进行访问，它们的密码都是password，具有的角色分别是USER和ADMIN。微服务的GET和POST端点分别通过USER和ADMIN角色进行保护，这就意味着普通用户可以访问只读的数据，而执行读取-写入操作的话，需要admin用户凭证。</p>
<p>对于微服务来说，基本认证是很好的一个选择，因为它遵循了很实用且广泛使用的认证协议。换句话说，很多的API调用者，包括移动应用，能够很容易地使用这一点来访问你的微服务。当你的认证需求超过了基本认证的功能时（如OpenID或OAuth），微服务可以使用Spring Security的全部功能来满足你的需求。</p>
<h3 id="消息集成">消息集成</h3><p>在任何的应用中，消息（messaging）都是一种很强大的工具，在一点上，微服务当然也不能例外。使用消息驱动架构开发的应用能够更好地支持可重用性和扩展性。Spring Boot能够让开发人员在编写微服务时将消息作为架构的核心组成部分，它使用到了Spring IO平台的企业集成模式（Enterprise Integration Patterns）实现，即Spring Integration。Spring Integration提供了开发消息驱动架构的基本结构，以及与分布式企业平台集成的模块。这种能力使得微服务可以使用来自抽象消息源的业务对象，这些消息源可以在应用内部，也可能是组织机构内部的其他服务所提供的。</p>
<p>尽管Boot并没有提供明确的Spring上下文自动化配置，但是它为Spring Integration提供了一个starter模块，它会负责引入Spring Integration项目的一系列依赖。这些依赖包括Spring Integration的核心库（Core library）、HTTP模块（用来进行面向HTTP的企业集成）、IP模块（用来进行基于Socket的集成操作）、File模块（用于进行文件系统集成）以及Stream模块（用于支持使用Stream的操作，如stdin和stdout）。这个starter模块为开发人员提供了健壮的消息功能的工具集，可以使已有的基础设施适应微服务API。</p>
<p>除了starter模块，Boot也为通过CLI构建的应用提供了编译器自动配置的功能。对于需要快速构建微服务原型并验证可行性的开发者来说，这种方式提供了一些捷径。使用企业级平台的应用可以快速地进行开发，在转移到正式的工程和构建系统之前，就能确认其价值。使用Spring Boot和Spring Integration使一个消息驱动的微服务运行起来非常简单，如程序清单1.24的样例代码所示。</p>
<p>程序清单1.24</p>
<pre><code><span class="variable">@RestController</span>
<span class="variable">@EnableIntegrationPatterns</span>
<span class="class"><span class="keyword">class</span> <span class="title">App</span> {</span>

  <span class="variable">@Bean</span>
  <span class="function"><span class="keyword">def</span> <span class="title">userLookupChannel</span><span class="params">()</span> {</span>
    new <span class="constant">DirectChannel</span>()
  }

  <span class="variable">@Bean</span>
  <span class="function"><span class="keyword">def</span> <span class="title">userTemplate</span><span class="params">()</span> {</span>
    new <span class="constant">MessagingTemplate</span>(userLookupChannel())
  }

  <span class="variable">@RequestMapping</span>(method=[<span class="constant">RequestMethod</span>.<span class="constant">GET</span>])
  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(<span class="variable">@RequestParam</span>(required=<span class="keyword">false</span>)</span> <span class="title">Long</span> <span class="title">id</span>) {</span>
    userTemplate().convertSendAndReceive( id ? id <span class="symbol">:</span> <span class="string">""</span>)
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">User</span> {</span>
  <span class="constant">Long</span> id
}

<span class="variable">@MessageEndpoint</span>
<span class="class"><span class="keyword">class</span> <span class="title">UserLookupObject</span> {</span>

  <span class="variable">@ServiceActivator</span>(inputChannel=<span class="string">"userLookupChannel"</span>)
  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(<span class="constant">Long</span> id)</span> {</span>
    id ? new <span class="constant">User</span>(<span class="symbol">id:</span>id) <span class="symbol">:</span> new <span class="constant">User</span>()
  }
}
</code></pre><p>使用消息驱动的方式来进行微服务的开发能提供很大的代码可重用性，并且能够与底层的服务提供者实现相解耦。在更为正式的场景之中，程序清单1.24的代码可能会负责组合数据，这些数据可能来自于数据库调用和企业组织中某个外部的服务集成。Spring Integration具有内置的设施用来进行负载路由（payload routing）和处理器链（handler chaining），这对于组合不同的数据来说，是一个很有吸引力的方案，我们的微服务可以作为一个数据的提供者（provider）。</p>
<h3 id="提供度量指标">提供度量指标</h3><p>微服务最重要的一个特性可能就是为报表终端（reporting agent）提供度量指标。不像那些功能完备的Web应用，微服务是轻量级的，设计时可能就不会规划提供报表界面或完备的接口来分析服务的活动。这种类型的操作最好是留给专门进行数据聚合和分析的应用，这些数据能够用来进行稳定性、性能以及商务智能的监控。基于这样的前提，微服务应该为这些工具提供端点，从而更加容易地获取有关该服务活动的数据。而报表工具负责将数据聚合到一个视图或报告中，对于关心数据的人这才是有意义的。</p>
<p>微服务的一些指标如稳定性和性能，对所有的应用都是通用的，但是与业务操作相关的指标必须由应用本身来具体进行管理。针对这一点，Spring Boot的actuator模块为开发人员提供了一种机制，允许开发人员通过/metrics端点以编码的方式暴露微服务状态的细节。Boot将指标拆分为“counter”和“gauge”两种类别：counter是所有以Number类型来展现的指标，而gauge是衡量双精度计算的指标。为了让微服务的开发人员更加容易地使用指标，Boot暴露了CounterService和GaugeService，它们可以自动织入到应用上下文之中。请参见程序清单1.25的样例，它阐述了如何通过CounterService对外暴露点击数。</p>
<p>程序清单1.25</p>
<pre><code>@<span class="type">RestController</span>
@<span class="type">RequestMapping</span>(<span class="string">"/user"</span>)
@<span class="type">EnableAutoConfiguration</span>
class <span class="type">UserController</span> {

  @<span class="type">Autowired</span>
  <span class="type">UserRepository</span> repository

  @<span class="type">Autowired</span>
  <span class="type">CounterService</span> counterService

  @<span class="type">RequestMapping</span>(<span class="keyword">method</span> = [<span class="type">GET</span>])
  def get() {
    get(null)
  }

  @<span class="type">RequestMapping</span>(value=<span class="string">"/{id}"</span>, <span class="keyword">method</span> = [<span class="type">GET</span>])
  def get(@<span class="type">PathVariable</span> <span class="type">Long</span> id) {
    counterService.increment id ? <span class="string">"queries.by.id.$id"</span> : <span class="string">"queries.without.id"</span>
    id ? repository.findOne(id) : repository.findAll()
  }
}
</code></pre><p>在点击/user端点时，有可能提供ID也有可能不提供ID，/metrics端点都会在counter.父节点下记录新的key。例如，如果我们只是查询/user端点而不带有ID的话，那么就会注册counter.queries.without.id指标。类似的，如果我们带有ID的话，那么就会看到有一个<code>counter.queries.by.id.&lt;id&gt;</code>的key，它能用来标记对于给定的ID已经进行了多少次查询。这些指标可能会有助于掌握最经常访问的User对象并指导要采取的行为，如缓存或数据库索引。类似于递增指标的数值，CounterService也允许将指标的值将为零。这对于跟踪打开的连接数或其他频率分布（histographic）的测量都是很有用处的。</p>
<p>gauge是稍微有所不同的一种类型指标，它会进行探索性的计算或基于请求来确定值。如GaugeService的JavaDocs所述，“gauge”可以测量任意的值，从方法执行的次数到会议室的温度。当需要为报表工具暴露细节时，这种类型的测量尤其适合于使用GaugeService。gauge的指标会在/metrics端点之下进行访问，并且带有gauge.前缀。它们的注册方式与counter有些差别，如程序清单1.26所示。</p>
<p>程序清单1.26</p>
<pre><code>@<span class="type">RestController</span>
@<span class="type">RequestMapping</span>(<span class="string">"/user"</span>)
@<span class="type">EnableAutoConfiguration</span>
class <span class="type">UserController</span> {

  @<span class="type">Autowired</span>
  <span class="type">UserRepository</span> repository

  @<span class="type">Autowired</span>
  <span class="type">CounterService</span> counterService

  @<span class="type">RequestMapping</span>(<span class="keyword">method</span> = [<span class="type">GET</span>])
  def get() {
    get(null)
  }

  @<span class="type">RequestMapping</span>(value=<span class="string">"/{id}"</span>, <span class="keyword">method</span> = [<span class="type">GET</span>])
  def get(@<span class="type">PathVariable</span> <span class="type">Long</span> id) {
    def start = new <span class="type">Date</span>().time
    def <span class="literal">result</span> = id ? repository.findOne(id) : repository.findAll()
    def time = new <span class="type">Date</span>().time - start
    gaugeService.submit(<span class="string">"user.get.db.time"</span>, time.doubleValue())
    <span class="literal">result</span>
  }
}
</code></pre><p>默认情况下，指标会存储在一个易失的内存数据库之中，但Boot同时也为应用上下文提供了MetricsRepository实现，它能支持更为持久化的行为。Boot自带了一个RedisMetricsRepository，它能够自动织入进来，从而将指标存储到Redis值存储之中，另外，可以编写自定义的实现将指标存储到任意的数据存储形式之中。</p>
<p>Boot还提供了对Coda Hale Metrics库的支持，它会将以特定名称开头的指标强制转换为对应的Metrics类型。例如，如果有一个指标是以histogram.开头，那么这个值将会作为Histogram对象类型。这种自动化的强制转换对于meter.和timer.key也是有效的，而普通的指标将会作为Gauge类型。</p>
<p>一旦微服务的指标在Boot中进行了注册，那么报表工具就可以通过/metrics端点来检索它们。已命名的指标可以通过/metrics端点获取，只需将指标的key名作为查询字符串的一部分即可。例如，如果只是访问gauge指标下的“user.get.db.time”，报表工具可以针对/metrics/gauge.user.get.db.time进行查询。</p>
<h3 id="打包Boot应用">打包Boot应用</h3><p>正如前面所讨论的，Boot提供了Maven和Gradle插件，它为构建系统的打包阶段提供了一种钩子（hook），以产生所谓的“胖jar”，在这种jar中包含了工程的所有依赖。当这个胖jar包执行时，应用将会运行在与工程开发期相同的嵌入式容器之中。这种简便的方式能够让开发人员省去很多麻烦，因为他们的部署包在开发期和运行时环境之中具有相同的依赖结构。这也能够缓解运维团队的焦虑，他们不用担心部署的场景，因为在部署时一个错误配置的运行时容器可能会带有某个特定的依赖，而在项目的开发期所依赖的可能是另外一个。</p>
<p>为了在Maven下执行打包，只需执行mvn package命令。Spring Boot的插件会备份工程所创建的原始jar并且在文件名上添加“.original”。在这里，能够得到可运行的jar，文件符合Maven artifact的命名约定，它可以按照工程最合适的方式进行部署。使用Gradle构建Boot工程同样很简单，只需执行标准的gradle build命令即可。类似于Maven，Boot插件在原有的打包任务之后使用Gradle安装了一个生命周期事件，并且会在build/libs目录下创建胖jar包。对所生成的胖jar包进行检查的一种方式就是所有依赖的jar都会位于归档文件的lib/目录下。</p>
<p>打包完成之后，胖jar包就能够像其他可运行的jar文件那样在命令行中执行了，也就是使用$JAVA_HOME/bin/java -jar path/to/myproject.jar命令。启动后，Boot应用的日志将会显示在控制台上。</p>
<p>对于需要部署到传统servlet容器之中的应用，Boot提供了一种方式以编码的方式初始化Web配置。为了使用这一点，Boot提供了可选的WebApplicationInitializer，它会使用servlet容器来注册应用，这会通过Servlet 3.0 API以编码的方式注册servlet并且会用到ServletContext。通过提供SpringBootServletInitializer的子类，Boot应用能够使用嵌入的Spring上下文来注册配置，这个Spring上下文是在容器初始化的时候创建的。为了阐述这个功能，考虑程序清单1.27中的示例代码。</p>
<p>程序清单1.27</p>
<pre><code><span class="annotation">@RestController</span>
<span class="annotation">@EnableAutoConfiguration</span>
<span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">SpringBootServletInitializer</span> {</span>

  <span class="annotation">@RequestMapping</span>(method = <span class="type">RequestMethod</span>.<span class="type">GET</span>)
  <span class="type">String</span> get() {
    <span class="string">"home"</span>
  }

  static void main(<span class="type">String</span>[] args) {
    <span class="type">SpringApplication</span>.run <span class="keyword">this</span>, args
  }

  <span class="annotation">@Override</span>
  <span class="type">SpringApplicationBuilder</span> configure(<span class="type">SpringApplicationBuilder</span> application) {
    application.sources <span class="type">Application</span>
  }
}
</code></pre><p>Application类中被重写的configure方法就是使用嵌入式的Spring上下文注册应用的地方。在更为正式的场景之中，这个方法可能会用来注册Spring Java配置类，它会定义应用中所有controller和服务的bean。</p>
<p>当将应用打包部署到servlet容器之中时，工程要构建为一个war文件。在Maven工程中，为了适应这一点，需要移除Boot插件，并且packaging需要明确定义为“war”类型，如程序清单1.28所示。</p>
<p>程序清单1.28</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">project</span> <span class="attribute">xmlns</span>=<span class="value">"http://maven.apache.org/POM/4.0.0"</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="title">modelVersion</span>&gt;</span>

    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>myproject<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;<span class="title">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="title">packaging</span>&gt;</span>

    <span class="tag">&lt;<span class="title">parent</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.0.RC1<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">parent</span>&gt;</span>

    <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span>
        <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span>

    <span class="tag">&lt;<span class="title">repositories</span>&gt;</span>
        <span class="tag">&lt;<span class="title">repository</span>&gt;</span>
            <span class="tag">&lt;<span class="title">id</span>&gt;</span>spring-snapshots<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
            <span class="tag">&lt;<span class="title">url</span>&gt;</span>http://repo.spring.io/libs-snapshot<span class="tag">&lt;/<span class="title">url</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">repository</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">repositories</span>&gt;</span>
<span class="tag">&lt;/<span class="title">project</span>&gt;</span>
</code></pre><p>对这个工程执行mvn install命令会在target目录下生成myproject-1.0.0-SNAPSHOT.war文件。使用Gradle构建的工程可以使用Gradle War Plugin，它为构建war文件暴露了一个war任务。类似于Maven的配置，Boot Gradle工程也需要移除所包含的Boot插件。产生war文件的示例Gradle构建脚本如程序清单1.29所示。</p>
<p>程序清单1.29</p>
<pre><code>apply plugin: <span class="string">'java'</span>
apply plugin: <span class="string">'war'</span>

repositories {
    mavenCentral()
    maven { url <span class="string">"http://repo.spring.io/snapshot"</span> }
    maven { url <span class="string">"http://repo.spring.io/milestone"</span> }
}

ext {
  springBootVersion = <span class="string">'1.0.0.BUILD-SNAPSHOT'</span>
}

dependencies {
    compile <span class="string">"org.springframework.boot:spring-boot-starter-web:${springBootVersion}"</span>
    compile <span class="string">"org.springframework.boot:spring-boot-starter-actuator:${springBootVersion}"</span>
}
</code></pre><p>对于Boot工程，使用这个构建脚本运行Gradle的war任务将会在build/libs目录下产生war文件。</p>
<p>不管是Maven还是Gradle的配置，一旦war文件产生，它就可以部署到任意兼容Servlet 3.0的应用服务器之中。部分兼容的容器包括Tomcat 7+、Jetty 8、Glassfish 3.x、JBoss AS 6.x/7.x以及Websphere 8.0。</p>
<hr>
<p><strong>延伸阅读 Spring</strong></p>
<blockquote>
<p>Boot团队已经编写了完整的指导和样例来阐述框架的功能。Blog文章、参考资料以及API文档都可以在Spring.IO网站上找到。项目的GitHub页面上可以找到示例的工程，更为具体的细节可以阅读Spring<br>Boot的参考手册。SpringSourceDev YouTube频道有一个关于Spring<br>Boot的webinar，它概述了这个项目的目标和功能。在去年在伦敦举行的Groovy &amp; Grails Exchange上，David<br>Dawson做了一个使用Spring Boot开发微服务的演讲。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/知识记录/Node.js/Node.js 的一些零碎知识/" itemprop="url">
                Node.js 的一些零碎知识
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Node-js/" itemprop="url" rel="index">
                  <span itemprop="name">Node.js</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/知识记录/Node.js/Node.js 的一些零碎知识/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/知识记录/Node.js/Node.js 的一些零碎知识/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="1-_NPM">1. NPM</h3><p>npm 全称是 Node Package Manager，相当于Java世界中的Maven。</p>
<p>操作办法，首先确认安装了node.js和npm模块，然后在node项目文件夹创建package.json，执行npm install会安装（npm install xxx）package内包含的库。例如：</p>
<pre><code>{
  "<span class="attribute">name</span>": <span class="value"><span class="string">"ShareConnect"</span></span>,
  "<span class="attribute">version</span>": <span class="value"><span class="string">"0.0.0"</span></span>,
  "<span class="attribute">private</span>": <span class="value"><span class="literal">true</span></span>,
  "<span class="attribute">scripts</span>": <span class="value">{
    "<span class="attribute">start</span>": <span class="value"><span class="string">"node ./bin/www"</span>
  </span>}</span>,
  "<span class="attribute">dependencies</span>": <span class="value">{
    "<span class="attribute">body-parser</span>": <span class="value"><span class="string">"~1.12.0"</span></span>,
    "<span class="attribute">cookie-parser</span>": <span class="value"><span class="string">"~1.3.4"</span></span>,
    "<span class="attribute">debug</span>": <span class="value"><span class="string">"~2.1.1"</span></span>,
    "<span class="attribute">ejs</span>": <span class="value"><span class="string">"~2.3.1"</span></span>,
    "<span class="attribute">express</span>": <span class="value"><span class="string">"~4.12.2"</span></span>,
    "<span class="attribute">morgan</span>": <span class="value"><span class="string">"~1.5.1"</span></span>,
    "<span class="attribute">serve-favicon</span>": <span class="value"><span class="string">"~2.2.0"</span></span>,
    "<span class="attribute">uuid-js</span>": <span class="value"><span class="string">"~0.7.5"</span></span>,
    "<span class="attribute">redis</span>": <span class="value"><span class="string">"~0.12.1"</span></span>,
    "<span class="attribute">connect</span>": <span class="value"><span class="string">"~2.9.0"</span>
  </span>}
</span>}
</code></pre><p>还有这样一篇文章：<a href="http://www.infoq.com/cn/articles/msh-using-npm-manage-node.js-dependence" target="_blank" rel="external">如何使用NPM来管理你的Node.js依赖</a></p>
<h3 id="2-_项目结构">2. 项目结构</h3><p>MVC分层结构经久考验，在此之上沉淀的技术资源也很丰富，Node.js同样可以设计出优雅高效的分层结果。</p>
<p>Connet中间件在MVC中合理的使用。</p>
<blockquote>
<p>借助Connect可以自由定制中间件的优势，可以自行提升性能或是设计出适合自己需要的项目。Connect自身提供了路由功能，在此基础上，可以轻松搭建MVC模式的框架，以达到开发效率和执行效率的平衡。以下是笔者项目中采用的目录结构，清晰地划分目录结构可以帮助划分代码的职责，此处仅供参考。</p>
</blockquote>
<pre><code>├── Makefile <span class="comment">// 构建文件，通常用于启动单元测试运行等操作</span>
├── app<span class="class">.js</span> <span class="comment">// 应用文件</span>
├── automation  <span class="comment">// 自动化测试目录</span>
├── bin  <span class="comment">// 存放启动应用相关脚本的目录</span>
├── conf  <span class="comment">// 配置文件目录</span>
├── controllers  <span class="comment">// 控制层目录------------------------C，Controller，控制器</span>
├── helpers  <span class="comment">// 帮助类库</span>
├── middlewares  <span class="comment">// 自定义中间件目录</span>
├── models  <span class="comment">// 数据层目录-----------------------------M，Model，模型</span>
├── node_modules  <span class="comment">// 第三方模块目录</span>
├── package<span class="class">.json</span>  <span class="comment">// 项目包描述文件</span>
├── public  <span class="comment">// 静态文件目录</span>
│   ├── images  <span class="comment">// 图片目录</span>
│   ├── libs  <span class="comment">// 第三方前端JavaScript库目录</span>
│   ├── scripts  <span class="comment">// 前端JavaScript脚本目录</span>
│   └── styles  <span class="comment">// 样式表目录</span>
├── test  <span class="comment">// 单元测试目录</span>
└── views  <span class="comment">// 视图层目录-----------------------------V，View，视图</span>
</code></pre><h3 id="3-_关于本项目基本的设计">3. 关于本项目基本的设计</h3><p>可以一个图来解释：<br><img src="http://note.wiz.cn/api/document/files/unzip/66e5c3f6-8482-11e1-a525-00237def97cc/6d3b0fec-73aa-4846-a15d-ff78e296af74.32632/index_files/f76767cb-d24f-4ef4-a718-cc3264db2dde.png" alt="UDP-返回-Post-set"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/04/07/知识记录/Java基础/java多线程中的volatile/" itemprop="url">
                java多线程中的volatile
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-04-07T00:20:36+08:00" content="2015-04-07">
            2015-04-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Java基础/" itemprop="url" rel="index">
                  <span itemprop="name">Java基础</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/04/07/知识记录/Java基础/java多线程中的volatile/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/知识记录/Java基础/java多线程中的volatile/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p><strong>volatile：</strong><br>英[‘vɒlətaɪl] 美[ˈvɑlətl, -ˌtaɪl]<br>adj. 易变的，不稳定的;（液体或油）易挥发的;爆炸性的;快活的，轻快的<br>[例句]A volatile political system makes these reforms hard to achieve.<br>而反复无常的政治体系又让这些方面的改革无法实施。<br>–xx翻译</p>
</blockquote>
<h1 id="一、volatile简述">一、volatile简述</h1><p>Java 语言提供了一种稍弱的同步机制,即 volatile 变量.用来确保将变量的更新操作通知到其他线程,保证了新值能立即同步到主内存,以及每次使用前立即从主内存刷新. 当把变量声明为volatile类型后,编译器与运行时都会注意到这个变量是共享的.</p>
<h1 id="二、_volatile线程安全？">二、 volatile线程安全？</h1><p>volatile 变量对所有线程是立即可见的,对 volatile 变量所有的写操作都能立即反应到其他线程之中,换句话说:volatile 变量在各个线程中是一致的,所以基于 volatile 变量的运算是线程安全的.  </p>
<p>这句话论据貌似没有错,论点确实错的.</p>
<h1 id="三、_valotile_为什么是线程不安全的？">三、 valotile 为什么是线程不安全的？</h1><pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VolatileTest</span>{

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span>  i;

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span>(<span class="params"></span>)</span>{
        i++;
    }
}
</code></pre><p>编译（<code>javap -c -l VolatileTest.class</code>）后，</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> VolatileTest {
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i;

  <span class="function"><span class="keyword">public</span> <span class="title">VolatileTest</span><span class="params">()</span></span>;
    Code:
       <span class="number">0</span>: aload_0       
       <span class="number">1</span>: invokespecial <span class="preprocessor">#<span class="number">1</span>                  <span class="comment">// Method java/lang/Object."&lt;init&gt;":()V</span></span>
       <span class="number">4</span>: <span class="keyword">return</span>        
    LineNumberTable:
      line <span class="number">1</span>: <span class="number">0</span>

  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>;
    Code:
       <span class="number">0</span>: getstatic     <span class="preprocessor">#<span class="number">2</span>                  <span class="comment">// Field i:I, 把i的值取到了操作栈顶,volatile保证了i值此时是正确的. </span></span>
       <span class="number">3</span>: iconst_1      
       <span class="number">4</span>: iadd                              <span class="comment">// increase,但其他线程此时可能已经把i值加大了好多</span>
       <span class="number">5</span>: putstatic     <span class="preprocessor">#<span class="number">2</span>                  <span class="comment">// Field i:I ,把这个已经out of date的i值同步回主内存中,i值被破坏了.</span></span>
       <span class="number">8</span>: <span class="keyword">return</span>        
    LineNumberTable:
      line <span class="number">6</span>: <span class="number">0</span>
      line <span class="number">7</span>: <span class="number">8</span>
}
</code></pre><p>从这个角度说 volatile 并不完全是线程安全的.</p>
<h1 id="四、_常见的用法">四、 常见的用法</h1><p>在Java内存模型中，有main memory，每个线程也有自己的memory (例如寄存器)。为了性能，一个线程会在自己的memory中保持要访问的变量的副本。这样就会出现同一个变量在某个瞬间，在一个线程的memory中的值可能与另外一个线程memory中的值，或者main memory中的值不一致的情况。<br>一个变量声明为volatile，就意味着这个变量是随时会被其他线程修改的，因此不能将它cache在线程memory中。以下例子展现了volatile的作用：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoppableTask</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{
    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> pleaseStop;

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">while</span> (!pleaseStop) {
            <span class="comment">// do some stuff...</span>
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tellMeToStop</span><span class="params">()</span> </span>{
        pleaseStop = <span class="keyword">true</span>;
    }
}
</code></pre><p>假如pleaseStop没有被声明为volatile，线程执行run的时候检查的是自己的副本，就不能及时得知其他线程已经调用tellMeToStop()修改了pleaseStop的值。 </p>
<p>Volatile一般情况下不能代替sychronized，因为volatile不能保证操作的原子性，即使只是i++，实际上也是由多个原子操作组成：read i; inc; write i，假如多个线程同时执行i++，volatile只能保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。如果配合Java 5增加的atomic wrapper classes，对它们的increase之类的操作就不需要sychronized。 </p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&laquo;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/photo.jpg" alt="Coder_Roc" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Coder_Roc</p>
        </div>
        <p class="site-description motion-element" itemprop="description">诚信，认真，专注，踏实</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">47</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">62</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/cshijiel" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/cshijiel" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/cshijiel" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp;  2014 - 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Coder_Roc</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"usee"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
